<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.4.1" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.4.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.4.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.4.1">


  <link rel="mask-icon" href="/images/logo.svg?v=6.4.1" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.4.1',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="Yun&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Yun&#39;s Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Yun&#39;s Blog">






  <link rel="canonical" href="http://yoursite.com/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Yun's Blog</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Yun's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Home</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />Archives</a>
  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/03/iOS-adjust-iOS12/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yun's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/03/iOS-adjust-iOS12/" itemprop="url">
                  iOS12 XCode10 适配
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-11-03 17:22:31" itemprop="dateCreated datePublished" datetime="2018-11-03T17:22:31+08:00">2018-11-03</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2018-11-23 17:24:09" itemprop="dateModified" datetime="2018-11-23T17:24:09+08:00">2018-11-23</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="iOS12-XCode10-适配"><a href="#iOS12-XCode10-适配" class="headerlink" title="iOS12 XCode10 适配"></a>iOS12 XCode10 适配</h1><h2 id="1-libstdc-弃用-报错Undefined-symbols"><a href="#1-libstdc-弃用-报错Undefined-symbols" class="headerlink" title="1. libstdc++弃用  报错Undefined symbols"></a>1. libstdc++弃用  报错Undefined symbols</h2><p> XCode10编译报错<code>ndefined symbols for architecture XXX</code>，如果你的工程中有libstdc++依赖（可从Linked Frameworks and Libraries 项查看），那么就会出现这类错误。</p>
<p>因为苹果在XCode10和iOS12中移除了libstdc++这个库，由libc++这个库取而代之，苹果的解释是libstdc++已经标记为废弃有5年了，建议大家使用经过了llvm优化过并且全面支持C++11的libc++库。</p>
<blockquote>
<p>libstdc++.dylib是C++98版本的标准库实现动态库，而libc++.dylib是C++11版本的标准库实现动态库。libc++是一个更加新的C++标准库实现，它完全支持C++11标准。因此苹果弃用了libstdc++.dylib，这符合苹果一贯的作风。</p>
</blockquote>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><ul>
<li><p><strong>最直接的是修改依赖库，支持libc++.dylib</strong></p>
</li>
<li><p><strong>临时方法</strong></p>
<p>  将libstdc++.dylib拷贝到 XCode中，共四个地方</p>
<p>  <a href="http://qnyuntmp.yunsoho.cn/libstdc++.zip" target="_blank" rel="noopener">libstdc++.dylib下载地址</a></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo cp CoreSimulator/* /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/CoreSimulator/Profiles/Runtimes/iOS.simruntime/Contents/Resources/RuntimeRoot/usr/lib/</span><br><span class="line">sudo cp MacOSX/* /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/lib/</span><br><span class="line">sudo cp iPhoneOS/* /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/usr/lib/</span><br><span class="line">sudo cp iPhoneSimulator/* /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/lib/</span><br></pre></td></tr></table></figure>
<h2 id="2-UICollectionViewCell-高度计算不正确"><a href="#2-UICollectionViewCell-高度计算不正确" class="headerlink" title="2. UICollectionViewCell 高度计算不正确"></a>2. UICollectionViewCell 高度计算不正确</h2><p><strong>更新 iOS12后，一定要检查所有用到UICollectionViewCell的界面，因为UICollectionViewCell可能出现高度计算不正确的现象。</strong></p>
<p>iOS12对AutoLayout做出了性能优化，但是更新 iOS12后，发现一些UICollectionViewCell的高度不正确，一时间也调试不出什么问题，因此就采用手动计算高度暂时解决。</p>
<p>这里有一篇同样的问题，解决思路可供参考<a href="http://www.cocoachina.com/ios/20181023/25267.html" target="_blank" rel="noopener">链接</a></p>
<h3 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h3><ul>
<li><p><strong>1. 手动计算高度</strong></p>
</li>
<li><p><strong>2. 忽略 contentView，直接把 subView 加到 cell 上</strong></p>
</li>
</ul>
<h2 id="3-StatusBar-网络状态"><a href="#3-StatusBar-网络状态" class="headerlink" title="3. StatusBar 网络状态"></a>3. StatusBar 网络状态</h2><p>如果app通过状态栏的网络状态指示器去判断手机当前联网状态，修改进行修改，因为iOS12 更改了StatusBar内部结构。</p>
<p><a href="https://blog.csdn.net/wxs0124/article/details/80613847" target="_blank" rel="noopener">参考链接</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">+ (NSString *)getIphoneXNetWorkStates &#123;    </span><br><span class="line">    UIApplication *app = [UIApplication sharedApplication];</span><br><span class="line">    id statusBar = [[app valueForKeyPath:@&quot;statusBar&quot;] valueForKeyPath:@&quot;statusBar&quot;];</span><br><span class="line">    id one = [statusBar valueForKeyPath:@&quot;regions&quot;];</span><br><span class="line">    id two = [one valueForKeyPath:@&quot;trailing&quot;];</span><br><span class="line">    NSArray *three = [two valueForKeyPath:@&quot;displayItems&quot;];</span><br><span class="line">    NSString *state = @&quot;无网络&quot;;</span><br><span class="line">    for (UIView *view in three) &#123;</span><br><span class="line">        //alert: iOS12.0 情况下identifier的变成了类&quot;_UIStatusBarIdentifier&quot;而不是NSString，所以会在调用“isEqualToString”方法时发生crash，</span><br><span class="line">        //修改前</span><br><span class="line">//        NSString *identifier = [view valueForKeyPath:@&quot;identifier&quot;];</span><br><span class="line">        //修改后</span><br><span class="line">        NSString *identifier = [[view valueForKeyPath:@&quot;identifier&quot;] description];</span><br><span class="line">        if ([identifier isEqualToString:@&quot;_UIStatusBarWifiItem.signalStrengthDisplayIdentifier&quot;]) &#123;</span><br><span class="line">            id item = [view valueForKeyPath:@&quot;_item&quot;];</span><br><span class="line"></span><br><span class="line">            //alert: 这个问题和上边一样itemId是_UIStatusBarIdentifier 类型，不是string</span><br><span class="line">            NSString *itemId = [[item valueForKeyPath:@&quot;identifier&quot;] description];</span><br><span class="line">            if ([itemId isEqualToString:@&quot;_UIStatusBarWifiItem&quot;]) &#123;</span><br><span class="line">                state = @&quot;WIFI&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            state = @&quot;不确定&quot;;</span><br><span class="line"></span><br><span class="line">        &#125; else if ([identifier isEqualToString:@&quot;_UIStatusBarCellularItem.typeDisplayIdentifier&quot;]) &#123;</span><br><span class="line">            UIView *statusBarStringView = [view valueForKeyPath:@&quot;_view&quot;];</span><br><span class="line">            // 4G/3G/E</span><br><span class="line">            state = [statusBarStringView valueForKeyPath:@&quot;text&quot;];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="iOS12新功能"><a href="#iOS12新功能" class="headerlink" title="iOS12新功能"></a>iOS12新功能</h2><h3 id="1-刘海屏判断"><a href="#1-刘海屏判断" class="headerlink" title="1. 刘海屏判断"></a>1. 刘海屏判断</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define isNotchMobile ([UIScreen instancesRespondToSelector:@selector(currentMode)] ? (CGSizeEqualToSize(CGSizeMake(1125, 2436), [[UIScreen mainScreen] currentMode].size)||CGSizeEqualToSize(CGSizeMake(1242, 2688), [[UIScreen mainScreen] currentMode].size)||CGSizeEqualToSize(CGSizeMake(828, 1792), [[UIScreen mainScreen] currentMode].size)) : NO)</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/12/iOS-book-EffectiveObjective-C2.0-chap7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yun's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/12/iOS-book-EffectiveObjective-C2.0-chap7/" itemprop="url">
                  EffectiveObjective-C2.0 笔记 - 第七部分
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-10-12 21:43:22" itemprop="dateCreated datePublished" datetime="2018-10-12T21:43:22+08:00">2018-10-12</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2018-11-05 10:03:49" itemprop="dateModified" datetime="2018-11-05T10:03:49+08:00">2018-11-05</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>EffectiveObjective-C2.0 笔记 - 第七部分</strong></p>
<h1 id="7-系统框架"><a href="#7-系统框架" class="headerlink" title="7. 系统框架"></a>7. 系统框架</h1><h2 id="7-1-熟悉系统框架"><a href="#7-1-熟悉系统框架" class="headerlink" title="7.1 熟悉系统框架"></a>7.1 熟悉系统框架</h2><p><strong>1. 框架：将一系列代码封装成动态库，并在其中放入描述其接口的头文件。</strong></p>
<blockquote>
<p>平时我们第三方框架用的是静态库，因为iOS 应用程序不允许其中包含动态库。</p>
</blockquote>
<p><strong>2. Foundation、CoreFoundation 框架平时用的比较多，“无缝桥接” 可以将这两种框架的对象平滑转换。</strong></p>
<p><strong>3. 常用框架：</strong></p>
<ul>
<li>CFNetwork</li>
<li>CoreAudio</li>
<li>AVFoundation</li>
<li>CoreData</li>
<li>CoreText</li>
</ul>
<h2 id="7-2-多用块枚举，少用for-循环"><a href="#7-2-多用块枚举，少用for-循环" class="headerlink" title="7.2 多用块枚举，少用for 循环"></a>7.2 多用块枚举，少用for 循环</h2><p><strong>遍历collection 有四种方式。最基本的办法就是for 循环，其次是NSEnumerator 遍历法及快速遍历法，最新、最先进的方式则是 “块枚举法”。</strong></p>
<p><strong>1. for 循环</strong></p>
<p>简单粗暴，遍历数组还可以，但是对于遍历字典或者set，就不太友好。  </p>
<p><strong>2. 使用Objective-C 1.0 的NSEnumerator 来遍历</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NSArray *array = @[@&quot;A&quot;,@&quot;B&quot;,@&quot;C&quot;];</span><br><span class="line">NSEnumerator *enumerator = [array objectEnumerator];</span><br><span class="line">NSString *string;</span><br><span class="line">while ((string = [enumerator nextObject]) != nil) &#123;</span><br><span class="line">	NSLog(@&quot;%@&quot;,string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种遍历使用相对比较统一，数组、字典和set 都可以这样子写，并且还有多种 “枚举器” 可供使用，例如反向遍历数组的枚举器。</p>
<p><strong>3. 快速遍历</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (&lt;#type *object#&gt; in &lt;#collection#&gt;) &#123;</span><br><span class="line">    &lt;#statements#&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>for in  这个更加简洁，如果某个类的对象支持快速遍历，那么就可以宣称自己遵从名为NSFastEnumeration 的协议，从而令开发者可以采用此语法来迭代改对象。此协议只定义了一个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (NSUInteger)countByEnumeratingWithState:(NSFastEnumerationState *)state objects:(id __unsafe_unretained _Nullable [_Nonnull])buffer count:(NSUInteger)len;</span><br></pre></td></tr></table></figure>
<p>由于NSEnumerator 对象也实现了NSFastEnumeration 协议，所以能用来执行快速遍历。但是快速遍历拿不到当前操作对象的下标。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSArray *array = @[@&quot;A&quot;,@&quot;B&quot;,@&quot;C&quot;];</span><br><span class="line">for (NSString *string in [array reverseObjectEnumerator]) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4. 基于块的遍历方式</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NSArray *array = @[@&quot;A&quot;,@&quot;B&quot;,@&quot;C&quot;];</span><br><span class="line">[array enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[array enumerateObjectsWithOptions:NSEnumerationReverse usingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>“块枚举法” 本身就能通过GCD来并发执行遍历操作，无须另行编写代码。而采用其他遍历则无法轻易实现这一点。</p>
<p>此方式对于其他相比，在遍历时候可以直接在块中获取更多信息，而且这种对于字典的遍历也是非常友好的，一次性可以返回键和值。并且还可以支持反向遍历。</p>
<h2 id="7-3-对自定义其内存管理语义的collection使用无缝桥接"><a href="#7-3-对自定义其内存管理语义的collection使用无缝桥接" class="headerlink" title="7.3 对自定义其内存管理语义的collection使用无缝桥接"></a>7.3 对自定义其内存管理语义的collection使用无缝桥接</h2><p><strong>无缝桥接</strong></p>
<p>使用 “无缝桥接” 计数，可以在定义于Foundation框架中的Objective-C类和定义于CoreFoundation框架中的C数据结构之间相互转换。</p>
<p><strong>1. 三种转换方式</strong></p>
<ul>
<li>__bridge 只是声明类型转变，但是不做内存管理规则的转变</li>
<li>__bridge_retained 表示将指针类型转变的同时，将内存管理的责任由原来的Objective-C 交给Core Foundation 来处理，也就是ARC 转变成 MRC</li>
<li>__bridge_transfer 表示将管理的责任由Core Foundation 转交给Objective-C，即将MRC转变成ARC</li>
</ul>
<ol>
<li>Foundation中字典对象无缝桥接：</li>
</ol>
<blockquote>
<p>Foundation中字典对象，对其键的内存管理语义为 “拷贝”，而值的语义是 “保留”。只能通过强大的无缝桥接技术，否则无法改变其语义。</p>
</blockquote>
<p>   CoreFoundation 框架的字典类型是CFDictionary，可变版本是CFMutableDictionary。</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">//CFMutableDictionary 用CFDictionaryCreateMutable 来创建</span><br><span class="line">//用CFDictionaryCreateMutable 定义</span><br><span class="line">CFMutableDictionaryRef CFDictionaryCreateMutable (</span><br><span class="line">  CFAllocatorRef allocator, </span><br><span class="line">  CFIndex capacity, </span><br><span class="line">  const CFDictionaryKeyCallBacks *keyCallBacks, </span><br><span class="line">  const CFDictionaryValueCallBacks *valueCallBacks</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">/*CFAllocatorRef 表示将要使用的内存分配器，CoreFoundation 对象里的数据结构需要占用内存，而分配器负责分配及回收这些内存，一般传NULL，表示采用默认的分配器。</span><br><span class="line"></span><br><span class="line">CFIndex 表示字典的初始大小，跟我们Foundation 字典的创建一样，并不限制最大容量 就是预先分配内存</span><br><span class="line"></span><br><span class="line">最后两个参数都是指向结构体的指针，定义了很多回调函数，用于指示字典中的键和值遇到各种事件时应该执行何种操作。</span><br><span class="line"></span><br><span class="line">CFDictionaryKeyCallBacks 的结构体定义</span><br><span class="line">typedef struct &#123;</span><br><span class="line">    CFIndex				version;</span><br><span class="line">    CFDictionaryRetainCallBack		retain;</span><br><span class="line">    CFDictionaryReleaseCallBack		release;</span><br><span class="line">    CFDictionaryCopyDescriptionCallBack	copyDescription;</span><br><span class="line">    CFDictionaryEqualCallBack		equal;</span><br><span class="line">    CFDictionaryHashCallBack		hash;</span><br><span class="line">&#125; CFDictionaryKeyCallBacks;</span><br><span class="line"></span><br><span class="line">CFDictionaryValueCallBacks 的结构体定义</span><br><span class="line">typedef struct &#123;</span><br><span class="line">    CFIndex				version;</span><br><span class="line">    CFDictionaryRetainCallBack		retain;</span><br><span class="line">    CFDictionaryReleaseCallBack		release;</span><br><span class="line">    CFDictionaryCopyDescriptionCallBack	copyDescription;</span><br><span class="line">    CFDictionaryEqualCallBack		equal;</span><br><span class="line">&#125; CFDictionaryValueCallBacks;</span><br><span class="line"></span><br><span class="line">version 参数目前应设置为0，表示版本号；</span><br><span class="line">其他参数都是函数指针，例如，字典加入了新的键与值，那么就会调用retain 函数，定义如下：</span><br><span class="line">typedef const void *(*CFDictionaryRetainCallBack)(</span><br><span class="line">	CFAllocatorRef allocator, </span><br><span class="line">	const void *value</span><br><span class="line">);</span><br><span class="line">retain 是个函数指针，其所指向的函数接受两个参数，其类型分别是CFAllocatorRef、const void *。传给此函数的value 参数表示即将加入字典中的键或值。而返回的void * 则表示加到字典里的最终值。我们可以这样子实现：</span><br><span class="line">const void *CustomCallback（CFAllocatorRef allocator，const void *value）&#123;</span><br><span class="line">	return value;</span><br><span class="line">&#125;</span><br><span class="line">如果用它充当retain 回调函数来创建字典，那么该字典就不会 “保留” 键和值。然后再利用无缝桥接搭配起来，就可以创建特殊的NSDictionary 对象，跟我们普通的字典不一样。</span><br><span class="line"></span><br><span class="line">开发者可以直接在CoreFoundation 层创建字典，于是就能修改内存管理语义，对键执行 “保留” 而非 “拷贝” 操作了。</span><br></pre></td></tr></table></figure>
<h2 id="7-4-构建缓存时选用NSCache而非-NSDictionay"><a href="#7-4-构建缓存时选用NSCache而非-NSDictionay" class="headerlink" title="7.4 构建缓存时选用NSCache而非 NSDictionay"></a>7.4 构建缓存时选用NSCache而非 NSDictionay</h2><p><strong>1. 实现缓存时应选用NSCache而非NSDictionary 对象。</strong></p>
<blockquote>
<p>NSCache 是专门来处理缓存的，在系统资源将要耗尽时，它可以自动删减缓存。而且是线程安全的，此外，它与字典不同，并不会拷贝健。</p>
</blockquote>
<p><strong>2. 可以给NSCache 对象设置上限</strong></p>
<blockquote>
<p>可以给NSCache 对象设置上限，用以限制缓存中的对象总个数及总成本，而这些尺度则定义了缓存删减其中对象的时机。但是绝对不要把这些尺度当成可靠的 “硬限制”，它们仅对NSCache其指导作用。</p>
</blockquote>
<p><strong>3. NSPurgeableData 与 NSCache 搭配使用</strong></p>
<blockquote>
<p> NSPurgeableData类是NSMutableData的子类，而且实现了NSDiscardableContent协议。将NSPurgeableData 与 NSCache 搭配使用，可实现自动清除数据的功能，也就是说，当NSPurgeableData 对象所占内存为系统丢弃时，该对象也会从缓存中移除。</p>
</blockquote>
<p><strong>4. 如果缓存使用得当，那么应用程序的响应速度就能提高。</strong></p>
<blockquote>
<p>只有那种 “重新计算起来很费事的” 数据，才值得放入缓存，比如那些需要从网络获取或从磁盘读取的数据。</p>
</blockquote>
<h2 id="7-5-精简initalize与load的实现代码"><a href="#7-5-精简initalize与load的实现代码" class="headerlink" title="7.5 精简initalize与load的实现代码"></a>7.5 精简initalize与load的实现代码</h2><p><strong>1. 在加载阶段，如果类实现了load 方法，那么系统就会调用它。分类里也可以定义此方法，类的load 方法要比分类中的先调用。与其他方法不同，load 方法不参与覆写机制。</strong></p>
<ul>
<li><p>对于加入运行期系统中的每个类及分类，必定会调用load这个方法，而且仅调用一次。意思就是程序启动的时候需要加载load方法，这个时候运行期系统也是出于 “脆弱状态”，在执行子类的load方法之前，必定会先执行所有超类的load 方法。</p>
</li>
<li><p>如果load 代码还依赖了其他类，那类的load 也必然会先执行，我们无法判断每个类的载入顺序，所以load 方法使用其他类是不安全的。</p>
</li>
<li><p>load 方法不遵从继承规则，如果某个类没实现load 方法，那么不管其各级超类是否实现此方法，系统都不会调用。</p>
</li>
<li><p>load 方法要实现的精简点，因为应用程序在执行load 方法会阻塞。load 一般作为调试用，很少用来做初始化操作。</p>
</li>
</ul>
<p><strong>2. load 与initialize 方法都应该实现得精简一些，这有助于保持应用程序的响应能力，也能减少引入 “依赖环” 的几率。</strong></p>
<ul>
<li><p>想执行与类相关的初始化操作，可以使用 <code>+(void)initialize</code>  这个方法，它跟load 有以下几个区别：</p>
<ul>
<li>这个方法是在首次使用这个类的时候调用，类似 “惰性调用” ，只有用到这个类才会调用。</li>
</ul>
</li>
</ul>
<ul>
<li>运行期在执行该方法的时候，是出于正常状态的，此时是可以安全调用任意类的任意方法，而且运行期系统会确保initialize 方法一定在 “线程安全的环境” 中执行。其他线程都要先阻塞，等initialize 执行完。</li>
<li>initialize 方法跟其他方法一样，某个类没有实现它，而超类方法实现了，那么就会运行超类的实现代码。</li>
</ul>
<ul>
<li><p>也就是说initalize 与 load 的实现代码要精简些。</p>
</li>
<li><p>若某个全局状态无法在编译期初始化，则可以放在initalize 里来做。（例如Objectice-C 对象，创建实例之前必须先激活运行期系统）</p>
</li>
</ul>
<h2 id="7-6-别忘了NSTimer会保留其目标对象"><a href="#7-6-别忘了NSTimer会保留其目标对象" class="headerlink" title="7.6 别忘了NSTimer会保留其目标对象"></a>7.6 别忘了NSTimer会保留其目标对象</h2><p><strong>1. 计时器放在运行循环里，它才能正常触发任务。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ scheduledTimerWithTimeInterval:target:selector:userInfo:repeats:</span><br></pre></td></tr></table></figure>
<p><strong>2. 计时器保留环</strong></p>
<p>   计时器会保留其目标对象，等到自身 “失效” 时再释放此对象，调用invalidate 方法可令计时器失效，另外，一次性的计时器在触发完任务之后也会失效。设置成重复执行模式的计时器，要注意 “保留环” 问题。</p>
<p><strong>3. 如何解决外界不调用invalidate方法也不产生 “保留环” 的问题</strong>。</p>
<p>   可以用块来解决这个问题，其实就是将timer的target 对象不要指向持有timer的对象，这里用的方法是让timer 的taerget 指向自己。</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//定义</span><br><span class="line">+ (NSTimer *)my_scheduledTimerWithTimeInterval:(NSTimeInterval)ti</span><br><span class="line">                                         block:(void(^)())block</span><br><span class="line">                                       repeats:(BOOL)yesOrNo;</span><br><span class="line"></span><br><span class="line">//实现</span><br><span class="line">+ (NSTimer *)my_scheduledTimerWithTimeInterval:(NSTimeInterval)ti</span><br><span class="line">                                         block:(void(^)())block</span><br><span class="line">                                       repeats:(BOOL)yesOrNo &#123;</span><br><span class="line">    return [self scheduledTimerWithTimeInterval:ti</span><br><span class="line">                                         target:self</span><br><span class="line">                                       selector:@selector(my_blockInvoke:)</span><br><span class="line">                                       userInfo:[block copy]</span><br><span class="line">                                        repeats:yesOrNo];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)my_blockInvoke:(NSTimer *)timer &#123;</span><br><span class="line">    void (^block) () = timer.userInfo;</span><br><span class="line">    if (block) &#123;</span><br><span class="line">        block();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/07/iOS-book-EffectiveObjective-C2.0-chap6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yun's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/07/iOS-book-EffectiveObjective-C2.0-chap6/" itemprop="url">
                  EffectiveObjective-C2.0 笔记 - 第六部分
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-10-07 21:11:45" itemprop="dateCreated datePublished" datetime="2018-10-07T21:11:45+08:00">2018-10-07</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2018-11-05 10:03:49" itemprop="dateModified" datetime="2018-11-05T10:03:49+08:00">2018-11-05</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>EffectiveObjective-C2.0 笔记 - 第六部分</strong></p>
<h1 id="6-块与大中枢派发"><a href="#6-块与大中枢派发" class="headerlink" title="6. 块与大中枢派发"></a>6. 块与大中枢派发</h1><h2 id="6-1-理解-“块”-这一概念"><a href="#6-1-理解-“块”-这一概念" class="headerlink" title="6.1 理解 “块” 这一概念"></a>6.1 理解 “块” 这一概念</h2><p><strong>一、块的基础知识</strong></p>
<p>块是C、C++、Objective-C 中的词法闭包。</p>
<p><strong>1. 块用 “^” 符号来表示，后面跟着一对花括号，括号里面是块的实现代码。</strong></p>
<blockquote>
<p>块其实就是个值，与 int，flout，Objective-C对象一样，而且自有其相关类型，可以赋值给变量；块类型的语法和函数指针类似。</p>
</blockquote>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">^&#123;</span><br><span class="line">	//block implementation herer	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//块类型的语法结构如下</span><br><span class="line">//return_type (^block_name)(parameters)</span><br><span class="line">void (^oneBlock)() = ^&#123;</span><br><span class="line">	//block implementation herer	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2. 在声明块的范围内，所有变量都可以被其捕获。</strong></p>
<blockquote>
<p>默认情况下被块捕获的变量是不可以在块里修改的，不过可以在声明变量的时候加上__block 修饰符，这样子就可以在块内修改了。</p>
</blockquote>
<blockquote>
<p>如果块所捕获的变量是对象类型，那么就会自动保留它，在系统释放这个块的时候，也会将其一并释放。</p>
</blockquote>
<blockquote>
<p>块总能修改实例变量，所以在声明时无须加__block。不过如果通过读取或写入操作捕获了实例变量，那么也会自动把self 变量一并捕获了，因为实例变量是与self 所指代的实例关联在一起的。</p>
</blockquote>
<blockquote>
<p>如果 self 所指代的那个对象同时也保留了块，那么这种情况通常就会导致”保留环”。</p>
</blockquote>
<p><strong>二、块的内部结构</strong></p>
<p><strong>1. 块本身也是对象，在存放块对象的内存区域中，首个变量是指向Class 对象的指针(isa 指针)。</strong></p>
<p>   <img src="http://ot8psglzx.bkt.clouddn.com/adadsa.png" alt=""></p>
<p><strong>2. invoke 变量是这个函数指针，指向块的实现代码。</strong></p>
<blockquote>
<p>函数原型至少要接受一个void* 型的参数，此参数代表块。为什么要把块对象作为参数传进来呢，因为在执行块的时候，要从内存中把这些捕获到的变量读出来。</p>
</blockquote>
<blockquote>
<p>descriptor 变量是指向结构体的指针，这个结构体包含块的一些信息。</p>
</blockquote>
<p><strong>三、全局块、栈块及堆块</strong></p>
<p><strong>1. 定义块的时候，其所占的内存区域是分配在栈中，意思就是，块只在定义它的那个范围内有效。</strong></p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void (^block)();</span><br><span class="line">if(***)&#123;</span><br><span class="line">	block = ^()&#123;</span><br><span class="line">		NSLog(@&quot;Block A&quot;);</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">	block = ^()&#123;</span><br><span class="line">		NSLog(@&quot;Block B&quot;);</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line">block();</span><br></pre></td></tr></table></figure>
<ul>
<li>栈块</li>
</ul>
<blockquote>
<p>定义在if else 语句中的两个块都分配在栈内存中，编译器会给每个块分配好栈内存，然而等离开了相应的范围之后，编译器有可能把分配给块内存覆写掉。所以这里执行block() 有危险。</p>
</blockquote>
<ul>
<li>堆块</li>
</ul>
<blockquote>
<p>为了解决这个问题，可以给块发送copy 消息以拷贝之。这样子的话，就可以把块从栈复制到堆可。一旦复制到堆上，块就成了带引用计数的对象了，后续的复制操作都不会真的执行复制，只是递增块对象的引用计数。</p>
</blockquote>
<ul>
<li>全局块</li>
</ul>
<blockquote>
<p>全局块声明在全局内存里，而且也不能被系统回收，相当于单例。由于运行该块所需的全部信息在编译期确定，所以可以把它作为全局块，这是一种优化技术：若把如此简单的块当成复杂的块来处理，那就会在复制及丢弃该块时执行一些无谓的操作。</p>
</blockquote>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void (^block)() = ^()&#123;</span><br><span class="line">		NSLog(@&quot;Block A&quot;);</span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="6-2-为常用的块类型创建-typedef"><a href="#6-2-为常用的块类型创建-typedef" class="headerlink" title="6.2 为常用的块类型创建 typedef"></a>6.2 为常用的块类型创建 typedef</h2><p><strong>1. 每个块都具备其 “固定类型”，因而可将其赋值给适当类型的变量。</strong></p>
<p><strong>2. 由于块类型的语法比较复杂难记，我们可以给块类型起个别名。</strong></p>
<blockquote>
<p>用C 语言中的 “类型定义” 的特性。typedef 关键字用于给类型起个易读的别名。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef int(^EOCSomeBlock)(BOOL flag, int value);</span><br><span class="line"></span><br><span class="line">EOCSomeBlock block = ^(BOOL flag, int value)&#123;</span><br><span class="line">	//to do</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="6-3-块降低代码分散程度"><a href="#6-3-块降低代码分散程度" class="headerlink" title="6.3 块降低代码分散程度"></a>6.3 块降低代码分散程度</h2><p><strong>场景：</strong></p>
<blockquote>
<p>异步方法执行完任务，需要以某种手段通知相关代码。经常使用的技巧是设计一个委托协议，令关注此事件的对象遵从该协议，对象成了delegate 之后，就可以在相关事件发生时得到通知了。</p>
</blockquote>
<p><strong>使用块来写的话，代码会更清晰，使得代码更加紧致。</strong></p>
<h2 id="6-4-用块引用其所属对象时不要出现保留环"><a href="#6-4-用块引用其所属对象时不要出现保留环" class="headerlink" title="6.4 用块引用其所属对象时不要出现保留环"></a>6.4 用块引用其所属对象时不要出现保留环</h2><p><strong>1. 如果块所捕获的对象直接或间接地保留了块本身，那么就得当心保留环问题。</strong></p>
<p><strong>2. 一定要找个合适的时机解除保留环，而不能把责任推给API的调用者。</strong></p>
<h2 id="6-5-多用派发队列，少用同步锁"><a href="#6-5-多用派发队列，少用同步锁" class="headerlink" title="6.5 多用派发队列，少用同步锁"></a>6.5 多用派发队列，少用同步锁</h2><p><strong>1. 同步锁</strong></p>
<blockquote>
<p>如果有多个线程要执行同一份代码，那么有时可能会出问题，这种情况下，通常要使用锁来实现某种同步机制。在GCD 出现之前，有两种办法：</p>
</blockquote>
<ul>
<li><p>采用内置的 “同步块”（synchronization block）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (void)synchronizedMethod &#123;</span><br><span class="line">	@synchronized(self)&#123;</span><br><span class="line">		//safe</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">这种写法会根据给定的对象，自动创建一个锁，并等待块中的代码执行完毕，执行到代码结尾，锁就释放了。</span><br><span class="line"></span><br><span class="line">但是，滥用 @synchronized(self) 则会降低代码效率，因为共用同一个锁的那些同步块，都必须按顺序执行。</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
</li>
<li><p>直接使用NSLock 对象，也可以使用NSRecursiveLock “递归锁”，线程能多次持有该锁，而且不会出现死锁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_lock = [[NSLock alloc] init];</span><br><span class="line"></span><br><span class="line">- (void)synchronizedMethod &#123;</span><br><span class="line">	[_lock lock];</span><br><span class="line">	//safe</span><br><span class="line">	[_lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>2. 对于上面两种方法，有些缺陷，同步块会导致死锁，直接使用锁对象，遇到死锁，就会非常麻烦。</strong></p>
<p><strong>3. GCD以更简单、更高效的形式为代码加锁。</strong></p>
<p><strong>例子：</strong></p>
<blockquote>
<p>属性是开发者经常需要同步的地方，可以使用atomic 特质来修饰属性，来保证其原子性，每次肯定可以从中获取到有效值，然而在同一个线程上多次调用获取方法(getter)，每次获取到结果未必相同，在两次访问操作之间，其他线程可能会写入新的属性值。</p>
</blockquote>
<p>   使用 “串行同步队列”，将读取操作及写入操作都安排在同一个队列里，即可保证数据同步。</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">_syncQueue = dispatch_queue_create(&quot;com.yun.syncQueue&quot;, NULL);</span><br><span class="line"></span><br><span class="line">- (NSString *)name &#123;</span><br><span class="line">    __block NSString *rstName;</span><br><span class="line">    dispatch_sync(_syncQueue, ^&#123;</span><br><span class="line">        rstName = _name;</span><br><span class="line">    &#125;);</span><br><span class="line">    return rstName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setName:(NSString *)name &#123;</span><br><span class="line">    dispatch_sync(_syncQueue, ^&#123;</span><br><span class="line">        _name = name;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面是用串行同步队列来保证数据同步：把设置操作与获取操作都安排在序列化的串行同步队列里执行，这样子，所有针对属性的访问操作都是同步的了。</p>
</blockquote>
<blockquote>
<p>进一步优化，设置方法不一定非得是同步的，因为不需要返回值。这样子可以提高设置方法的执行速度，而读取操作与写入操作依然会按照顺序执行。</p>
</blockquote>
<p><strong>优化：多个获取方法可以并发执行，而获取方法与设置方法不能并发执行。</strong></p>
<p>   我们还可以使用并发队列来实现,现在都是在并发队列上面执行任务，但是顺序不能控制，我们可以用栅栏(barrier)来解决。</p>
<p>   这两个函数可以向队列派发块，将其作为栅栏来使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dispatch_barrier_sync(dispatch_queue_t queue,^(void)block)</span><br><span class="line">dispatch_barrier_async(dispatch_queue_t queue,^(void)block)</span><br></pre></td></tr></table></figure>
<p>   在队列中，栅栏块必须单独执行，不能与其他块并行，这只对并发队列有意义，因为串行队列中的块总是按照顺序逐个执行的。并发队列如果发现接下来要处理的块是栅栏块，那么就一直要等到当前所有的并发块都执行完毕，才会单独执行这个栅栏块。执行完栅栏块，再按照正常方式向下处理。<br>   */</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">-----&gt; 现在并发队列 还不能满足要求</span><br><span class="line">_syncQueue1 = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">- (NSString *)name &#123;</span><br><span class="line">    __block NSString * rstName;</span><br><span class="line">    dispatch_sync(_syncQueue1, ^&#123;</span><br><span class="line">        rstName = _name;</span><br><span class="line">    &#125;);</span><br><span class="line">    return rstName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setName:(NSString *)name &#123;</span><br><span class="line">    dispatch_async(_syncQueue1, ^&#123;</span><br><span class="line">        _name = name;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-----&gt; 转换写法 用栅栏块控制属性的设置方法 不能并行</span><br><span class="line">_syncQueue1 = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">- (NSString *)name &#123;</span><br><span class="line">    __block NSString * rstName;</span><br><span class="line">    dispatch_sync(_syncQueue1, ^&#123;</span><br><span class="line">        rstName = _name;</span><br><span class="line">    &#125;);</span><br><span class="line">    return rstName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setName:(NSString *)name &#123;</span><br><span class="line">    dispatch_barrier_async(_syncQueue1, ^&#123;</span><br><span class="line">        _name = name;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-6-多用GCD，少用performSelector-方法"><a href="#6-6-多用GCD，少用performSelector-方法" class="headerlink" title="6.6 多用GCD，少用performSelector 方法"></a>6.6 多用GCD，少用performSelector 方法</h2><p><strong>建议用GCD 替代performSelector，对于performSelector 遇到的问题，我们都可以用GCD 解决</strong></p>
<ol>
<li><p>performSelector 可以任意调用方法，还可以延迟调用，还可以指定运行方法所用的线程，这些由 Objective-C 的动态性决定。</p>
</li>
<li><p>但是如果是动态来调用performSelector 方法的时候，编译器都不知道执行的选择子是什么，必须到了运行期才能确定，这种情况在ARC下会报警告，因为编译器不知道方法名，所以不能运用ARC内存管理规则来判定返回值是否应该释放，对于这种情况ARC不会帮我们添加任何释放操作。</p>
</li>
<li><p>performSelector 方法调用的时候对于返回类型只能是void或对象类型，对于有返回值的需要自己做多次转换，对于参数的也最多只能传2个，介于此performSelector 还是比较不方便的。</p>
</li>
<li><p>如果想把任务放在另一个线程上执行，那么最好不要用performSeletor  系列方法，而是应该把任务封装到块里，然后调用大中枢派发机制的相关方法来实现。</p>
</li>
</ol>
<h2 id="6-7-掌握GCD-及操作队列的使用时机"><a href="#6-7-掌握GCD-及操作队列的使用时机" class="headerlink" title="6.7 掌握GCD 及操作队列的使用时机"></a>6.7 掌握GCD 及操作队列的使用时机</h2><p><strong>1. 使用NSOperation执行后台任务</strong></p>
<ul>
<li><p>GCD在很多地方特别优秀，但是在执行后台任务时，GCD不一定是最佳方式，还有一种技术叫做NSOperationQueue，开发者可以把操作以NSOperation子类的形式放在队列中，而这些操作也可以并发执行。</p>
</li>
<li><p>GCD是纯C的API，操作队列的则是Objective-C的对象。用NSOperationQueue类的“addOperationWithBlock” 方法搭配NSBlockOperation类操作队列，其语法与纯GCD方式非常类似。使用NSOperation及NSOperationQueue 的好处如下：</p>
</li>
</ul>
<p><strong>1) 取消某个操作。</strong></p>
<blockquote>
<p>如果使用操作队列，那么想取消操作是很容易的。运行任务之前，可以在NSOperation 对象调用cancel 方法，该方法会设置对象内的标识位，用以表明此任务不需执行，不过，已经启动的任务无法取消。若不是操作队列，而是把块安排到GCD 队列，那就无法取消了。那套架构是 “安排好任务之后就不管了”。开发者可以在应用层自己来实现取消功能，不过这样子做需要编写很多代码，而那些代码其实已经由操作队列实现好了。</p>
</blockquote>
<p><strong>2. 指定操作间的依赖关系。</strong></p>
<blockquote>
<p>一个操作可以依赖其他多个操作。开发者能够指定操作之间的依赖关系，使特定的操作必须在另外一个操作顺序执行完毕方可执行，比方说，从服务器下载并处理文件的动作，可以用操作来表示，而在处理其他文件之前，必须先下载 “清单文件”。后续的下载操作，都要依赖于先下载清单文件这一操作。如果操作队列允许并发的话，那么后续的多个下载操作就可以同时执行，但前提是它们所依赖的那个清单文件下载操作已经执行完毕。</p>
</blockquote>
<p><strong>3. 通过键值观测机制监控NSOperation对象的属性。</strong></p>
<blockquote>
<p>NSOperation 对象有许多属性都适合通过键值观测机制（KVO）来监听，比如可以通过isCancalled 属性来判断任务是否取消。如果想在某个任务变更期状态时得到通知，或是想用比GCD 更为精细的方式来控制所要执行的任务，那么键值观测机制会很有用。</p>
</blockquote>
<p><strong>4. 制定操作的优先级。</strong></p>
<blockquote>
<p>操作的优先级表示此操作与队列其他操作之间的优先关系。优先级高的操作先执行，优先级低的后执行。操作队列的调度算法已经比较成熟。反之，GCD 则没有直接实现此功能的办法，GCD 的队列有优先级，但是是针对整个队列来说的，而不是针对每个块来说的。对于优先级这一点，操作队列所提供的功能比GCD 更为便利。</p>
</blockquote>
<p><strong>5. 重用NSOperation 对象。</strong></p>
<blockquote>
<p>系统内置类一些NSOperation 的子类供开发者调用，要是不想用这些固有子类的话，那就得自己来创建了。这些类就是普通的Objective-C 对象，能够存放任何信息。对象在执行时可以充分利用存于其中的信息，而且还可以随意调用定义在类中的方法。这比派发队列中哪些简单的块要强大。这些NSOperation 类可以在代码中多次使用。</p>
</blockquote>
<h2 id="6-8-通过Dispatch-Group机制，根据系统资源状况来执行任务"><a href="#6-8-通过Dispatch-Group机制，根据系统资源状况来执行任务" class="headerlink" title="6.8 通过Dispatch Group机制，根据系统资源状况来执行任务"></a>6.8 通过Dispatch Group机制，根据系统资源状况来执行任务</h2><p><strong>1. 一系列任务可归入一个dispatch group之中。开发者可以在这组任务执行完毕时获得通知。</strong></p>
<p><strong>2. 通过dispatch group，可以在并发式派发队列里同时执行多项任务。此时GCD会根据系统资源状况来调度这些并发执行的任务。开发者若自己实现此功能，则需编写大量代码。</strong></p>
<h2 id="6-9-使用dispatch-once来执行只需运行一次的线程安全代码"><a href="#6-9-使用dispatch-once来执行只需运行一次的线程安全代码" class="headerlink" title="6.9 使用dispatch_once来执行只需运行一次的线程安全代码"></a>6.9 使用dispatch_once来执行只需运行一次的线程安全代码</h2><ol>
<li>只需执行一次的线程安全代码时，使用dispatch_once。</li>
</ol>
<blockquote>
<p>经常需要编写 “只需执行一次的线程安全代码”。通常使用GCD 所提供的dispatch_once 函数，很容易就能实现此功能。</p>
</blockquote>
<blockquote>
<p>使用dispatch_once 可以简化代码，并且彻底保证线程安全</p>
</blockquote>
<ol>
<li>单例示例</li>
</ol>
<blockquote>
<p>对于单例我们创建唯一实例，之前都是用@synchronized 加锁来解决多线程的问题，GCD 提供了一个更加简单的方法来实现。    </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//单例</span><br><span class="line">+(instancetype)shareInstance&#123;</span><br><span class="line">    static EOCClass *shareInstance;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        shareInstance = [EOCClass new];</span><br><span class="line">    &#125;);</span><br><span class="line">    return shareInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-10-不要使用dispatch-get-current-queue"><a href="#6-10-不要使用dispatch-get-current-queue" class="headerlink" title="6.10 不要使用dispatch_get_current_queue"></a>6.10 不要使用dispatch_get_current_queue</h2><ol>
<li><p>dispatch_get_current_queue 函数的行为常常与开发者所预期的不同。此函数已经废弃(iOS 6.0起废除)，只应做调试之用。</p>
</li>
<li><p>由于派发队列是按层级来组织的，所以无法单用某个队列对象来描述 “当前队列” 这一概念。</p>
</li>
<li><p>dispatch_get_current_queue 函数用于解决由不可重入的代码引发的死锁，然而能用此函数的解决的问题，通常也能改用 “队列特定数据” 来解决。</p>
</li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/03/iOS-book-EffectiveObjective-C2.0-chap5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yun's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/03/iOS-book-EffectiveObjective-C2.0-chap5/" itemprop="url">
                  EffectiveObjective-C2.0 笔记 - 第五部分
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-10-03 22:12:32" itemprop="dateCreated datePublished" datetime="2018-10-03T22:12:32+08:00">2018-10-03</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2018-11-05 10:03:49" itemprop="dateModified" datetime="2018-11-05T10:03:49+08:00">2018-11-05</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>EffectiveObjective-C2.0 笔记 - 第五部分</strong></p>
<h1 id="5-内存管理"><a href="#5-内存管理" class="headerlink" title="5 内存管理"></a>5 内存管理</h1><h2 id="5-1-理解引用计数"><a href="#5-1-理解引用计数" class="headerlink" title="5.1 理解引用计数"></a>5.1 理解引用计数</h2><h3 id="1、引用计数"><a href="#1、引用计数" class="headerlink" title="1、引用计数"></a>1、引用计数</h3><p>Objective-C 语言使用引用计数来管理内存，每个对象都有个可以递增递减的计数器，用以表示当前有多少个事物想令此对象继续存活下去。当这个计数器归零那么这个对象就会被释放。</p>
<blockquote>
<p>查看引用计数的方法叫做 retainCount 但是实际并不建议使用这个方法调试代码</p>
</blockquote>
<p>NSObject 协议声明下面三个方法用于操作计数器，以递增或递减其值：</p>
<ul>
<li>retain 递增保留计数</li>
<li>release 递减保留计数</li>
<li>autorelease 待稍后清理 “自动释放池” 时，再递减保留计数</li>
</ul>
<p>在调用release 之后，对象所占的内存可能会被回收，这样子在调用对象的方法就可能使程序崩溃，这里 “可能” 的意思是对象所占的内存在 “解除分配” （deallocated）之后，只是放回 “可用内存池”（avaiable pool）。若果执行方法时尚未覆写对象，那么对象仍然有效。</p>
<p>为避免在不经意间使用无效对象，一般在调用完release 之后都会清空指针，保证不会出现可能指向无效对象的指针，这种指针通常被称为 “悬挂指针”（dangling pointer）。</p>
<p>所有的对象最终都间接或直接的被一个根对象所引用，macOS 应用是 NSApplication 对象，iOS 则是 UIApplication 对象，这两个对象都是应用启动时创建的单例</p>
<h3 id="2、自动释放池-autorelease"><a href="#2、自动释放池-autorelease" class="headerlink" title="2、自动释放池 autorelease"></a>2、自动释放池 autorelease</h3><p>调用release 会立刻递减对象的保留计数（这里可能会令系统回收此对象），调用autorelease 方法，并不会马上减少对象的引用计数，而是在下一次 Event Loop（事件循环）时减少，以达到延迟释放对象的效果。</p>
<p>autorelease 能延长对象声明周期，使其在跨越方法调用边界后依然可以存活一段时间。</p>
<p>调用 release 并不会使对象被释放，对象释放被释放取决于引用计数是否为 0</p>
<h2 id="5-2-以-ARC-简化引用计数"><a href="#5-2-以-ARC-简化引用计数" class="headerlink" title="5.2 以 ARC 简化引用计数"></a>5.2 以 ARC 简化引用计数</h2><p><strong>1. 内存泄漏：</strong></p>
<blockquote>
<p>没有正确的释放已经不再使用的内存。</p>
</blockquote>
<p><strong>2. ARC自用引用计数</strong></p>
<p><strong>1) ARC 只是自动为代码添加内存管理相关的代码</strong></p>
<blockquote>
<p>ARC 是通过在编译时在我们的代码中插入对应的内存管理代码，并且只适用于 Objective-C 的代码，使用ARC 时，引用计数实际上还是要执行的，只是保留与释放操作是由ARC 自动添加的。</p>
</blockquote>
<p><strong>2) 在 ARC 下，不允许调用内存管理方法 retain，release，autorelease，dealloc</strong></p>
<blockquote>
<p>ARC会自动执行以下等操作，所以在ARC下调用这些内存管理方法是<strong>非法的</strong>。</p>
</blockquote>
<ul>
<li>retain</li>
<li>release</li>
<li>autorelease</li>
<li>dealloc</li>
</ul>
<blockquote>
<p>ARC 在调用这些方法时，并不是普通的Objective-C 消息派发机制，而是直接调用其底层的C 语言函数，这样子性能会更好。</p>
</blockquote>
<p><strong>3. 使用ARC 时必须遵循的方法命名规则</strong></p>
<p>将内存管理语义在方法名中表示出来，若方法名以下列词语开头，则返回的对象归调用者所有：</p>
<ul>
<li>alloc</li>
<li>new</li>
<li>copy</li>
<li>mutableCopy</li>
</ul>
<p><strong>4. 变量的内存管理语义</strong></p>
<p><strong>1) ARC 也会处理局部变量与实例变量的内存管理。</strong></p>
<p><strong>2 )我们通常会给局部变量加上修饰符来打破 “块”（block）所引入的 “保留环”（retain cycle）。</strong></p>
<p>变量内存管理语义修饰符</p>
<ul>
<li>__strong：默认，强引用，表示需要保留这个值</li>
<li>__weak：弱引用，表示不保留这个值，并且如果系统回收这个对象，那么在获取此变量的值的时候会的到 nil</li>
<li>__unsafe_unretained：不安全的引用，不保留此值，系统回收这个对象的时候，不会清空变量的值</li>
<li>__autoreleasing：把对象“按引用传递”给方法时使用，表示此值在方法返回时自动释放</li>
</ul>
<p><strong>5. ARC 如何清理实例变量</strong></p>
<p>对实例变量进行内存管理，必须在 “回收分配给对象的内存” 时生成必要的清理代码。凡事具备强引用的变量，都必须释放，ARC 会在dealloc 方法中插入这些代码。</p>
<ul>
<li>ARC 只负责管理Objective-C 对象的内存</li>
</ul>
<blockquote>
<p>ARC 会借用Objective-C++ 的一项特性来生成清理代码，在回收对象时，待回收对象会调用所有C++ 对象的析构函数，编译器如果发现某个对象里含有C++ 对象，就会生成名为.cxx_desteuct 的方法，ARC 借助此特性，在该方法中生成清理内存所需的代码。</p>
</blockquote>
<ul>
<li>对于非Objective-C 的对象，需要我们手动清理。</li>
</ul>
<blockquote>
<p>如 CoreFoundation 对象不归ARC 管理，开发者必须适时调用CFRetain/CFRelease。</p>
</blockquote>
<p><strong>6. 覆写内存管理方法</strong></p>
<p>非ARC 时可以覆写内存管理方法，在ARC 下禁止覆写内存管理方法，会干扰到ARC 分析对象生命周期的工作。</p>
<h2 id="5-3-在-dealloc-方法中只释放引用，并解除监听"><a href="#5-3-在-dealloc-方法中只释放引用，并解除监听" class="headerlink" title="5.3 在 dealloc 方法中只释放引用，并解除监听"></a>5.3 在 dealloc 方法中只释放引用，并解除监听</h2><p>对象在经历生命周期后，最终会为系统回收，这时候就要执行dealloc 方法。每个对象生命周期内，此方法只会调用一次，也就是保留计数为0 的时候，绝对不能自己调用dealloc 方法，运行期会在适当的时候调用，一旦调用，对象就不再有效了，后续的方法调用均是无效的。</p>
<p>dealloc 方法主要是释放对象所拥有的引用，也就是把Objective-C 对象都释放掉，ARC 会通过自动生成的.cxx_desteuct 方法，在dealloc 中为你自动添加这些释放代码。但是其他非Objective-C 对象就需要自己手动释放了。</p>
<p><strong>1. dealloc 方法中需要做的事情：</strong></p>
<ul>
<li>释放对象所拥有的引用，持有的对象(ARC 下自动加入施放代码)</li>
<li>清理观察者</li>
<li>清理通知</li>
<li>如果不使用 ARC，那么需要调用 [super dealloc] 方法</li>
</ul>
<p><strong>2. dealloc 方法中不适合做的事情：</strong></p>
<ul>
<li>释放开销较大或系统内稀缺的资源（文件描述符，套接字，大量内存等）</li>
</ul>
<blockquote>
<p>因为 dealloc 方法并不会在特定时机调用，一般对于使用这样资源的对象都需要提供名字类似 open 和 close 的方法处理申请和释放资源的行为</p>
</blockquote>
<ul>
<li>执行异步任务</li>
</ul>
<blockquote>
<p>异步方法执行后，对象可能已经施放</p>
</blockquote>
<ul>
<li>尽量不要去调用方法，包括属性的存取方法</li>
</ul>
<blockquote>
<p>在dealloc 里尽量不要去调用方法，包括属性的存取方法，因为在这些方法可能会被覆写，并在其中做一些无法在回收阶段安全执行的操作。</p>
</blockquote>
<h2 id="5-4-编写-“异常安全代码”-时留意内存管理问题"><a href="#5-4-编写-“异常安全代码”-时留意内存管理问题" class="headerlink" title="5.4 编写 “异常安全代码” 时留意内存管理问题"></a>5.4 编写 “异常安全代码” 时留意内存管理问题</h2><p><strong>1. C++ 和 Objective-C 的异常互相兼容，可以相互抛出捕获</strong></p>
<blockquote>
<p>纯C 中没有异常，C++与Objective-C 都支持异常，在运行期系统中C++与Objective-C 异常相互兼容，也就是说，从其中一门语言里抛出的异常能用另外一门语言所编写的 “异常处理程序” 来捕获。</p>
</blockquote>
<p><strong>2. 捕获异常时，一定要注意将try 块内创建的对象清理干净。</strong></p>
<blockquote>
<p>Objective-C 错误模型表明，异常只应发生严重错误后抛出，发生异常如何管理内存很重要，在try 块中保留某个对象的，但是在释放它之前抛出异常了，这时候就无法正常释放了，这时候需要借助@finally 块来保证释放对象的代码一定会执行，且只执行一次。</p>
</blockquote>
<p><strong>3. 默认情况下，ARC 不生成安全处理异常所需的清理代码。</strong></p>
<blockquote>
<p>在ARC 不会自动生成处理异常中的代码，因为这样子需要加入大量的样板代码，以便追踪待清理的对象，从而在抛出异常时将其释放。可以这段代码会严重运行期的性能，还会增加应用程序的大小。</p>
</blockquote>
<blockquote>
<p>可以通过<code>-fobjc-arc-exceptions</code> 这个编译编织来开启这个功能，但是这个功能不应该作为生成这种安全处理异常所用的附加代码，应该是让代码处于Objective-C++模式。</p>
</blockquote>
<h2 id="5-5-以弱引用避免保留环"><a href="#5-5-以弱引用避免保留环" class="headerlink" title="5.5 以弱引用避免保留环"></a>5.5 以弱引用避免保留环</h2><p><strong>1. 相互引用和对象引用环</strong></p>
<blockquote>
<p>几个对象都以某种方式互相引用，从而形成 “环”，这种情况通常会泄漏内存，因为没有东西引用环中对象，这样子环里的对象互相引用，不会被系统回收，会导致内存泄漏。</p>
</blockquote>
<p><strong>2. 避免保留环的最佳方式就是弱引用</strong></p>
<ul>
<li>非 ARC 的情况下使用 assign 或者 unsafe_unretained 来修饰弱引用属性</li>
<li>ARC 的情况下使用 weak 来修饰弱引用的属性，因为 weak 的属性在对象被释放后会自动设置为 nil</li>
</ul>
<blockquote>
<p>一般来说，如果不拥有某对象，就不要保留它，这条规则对collection 例外，collection 虽然不直接拥有其内容，但是它要代表自己所属的那个对象来保留这些元素。</p>
</blockquote>
<h2 id="5-6-以-“自动释放池块”-降低内存峰值"><a href="#5-6-以-“自动释放池块”-降低内存峰值" class="headerlink" title="5.6 以 “自动释放池块” 降低内存峰值"></a>5.6 以 “自动释放池块” 降低内存峰值</h2><p><strong>1. 释放对象有两种方式：</strong></p>
<p><strong>1) 一种是调用release 方法，使其保留计数立即递减</strong></p>
<blockquote>
<p>ARC下不能主动调用</p>
</blockquote>
<p><strong>2) 一种是调用autorelease 方法</strong></p>
<blockquote>
<p>将对象放入 “自动释放池” 中，自动释放池用于存放那些需要稍后某个时刻释放的对象，清空（drain）自动释放池时，系统会向其中的对象发送release 消息。</p>
</blockquote>
<blockquote>
<p>创建自动释放池，系统会自动创建一些线程，这些线程默认都有自动释放池，每次执行 “事件循环”时，都会将其清空。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@autoreleasepool &#123;</span><br><span class="line">//...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2. 内存峰值：</strong></p>
<blockquote>
<p>是指应用程序在某个特定时段内的最大内存用量。如：循环创建大量对象的时候</p>
</blockquote>
<ul>
<li>对象有可能会放在自动释放池里面，需要等到线程执行下一次事件循环才会清空，这里会导致应用程序所占内存会持续增加，等到临时对象释放的时候，内存用量又会突然下降。我们现在就想把这个内存峰值给降低下来。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0;i &lt; 100000;i++)&#123;</span><br><span class="line">    @autorelease&#123;</span><br><span class="line">        NSObject *object = [NSObject new];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-7用-“僵尸对象”-调试内存管理问题"><a href="#5-7用-“僵尸对象”-调试内存管理问题" class="headerlink" title="5.7用 “僵尸对象” 调试内存管理问题"></a>5.7用 “僵尸对象” 调试内存管理问题</h2><p><strong>1. 僵尸对象用于调试代码是否会使用到已经被销毁的对象</strong></p>
<blockquote>
<p>向已回收的对象发送消息是不安全的，是否崩溃这个是看对象所占的内存有没有为其他内容所覆写。</p>
</blockquote>
<ul>
<li>Cocoa 提供 “僵尸对象”（Zombie Object）这个非常方便的功能，开启后，运行期系统会把已经回收的实例转换成特殊的 “僵尸对象”，而不会真正回收它们。这个对象所在的核心内无法重用，因此不可能遭到覆写，僵尸对象收到消息后，会抛出异常。</li>
</ul>
<p><strong>2. XCODE 设置</strong></p>
<blockquote>
<p>Xcode Scheme 中的Enable Zombie Objects 选项，打开会将NSZombieEnabled 环境变量设成YES。</p>
</blockquote>
<ul>
<li><p>系统在即将回收时，会执行一个附加步骤，将对象转换成僵尸对象，而不彻底回收。僵尸类是从名为<em>NSZombie</em> 的模版类复制出来的。<em>NSZombie</em> 类并未实现任何方法，此类没有超类，因此跟NSObject 一样，也是一个 “根类”，该类只有一个实例变量，叫做isa，所以发给他的消息都要经过 “完整的消息转发机制” 。</p>
</li>
<li><p>在完整的消息转发机制中，<strong><em>forwarding</em></strong> 是核心，检查接受消息的对象所属的类名，若是<em>NSZombie</em> ，则表示消息接受者是僵尸对象，需要特殊处理。</p>
</li>
<li><p>系统在回收对象时，可以不将其真的回收，而是把它转化成僵尸对象。通过环境变量NSZombieEnabled 可开启此功能。</p>
</li>
<li><p>系统会修改对象的isa 指针，令其指向特殊的僵尸类，从而使该对象变成僵尸对象。僵尸类能够响应所有的选择子，响应方式为：打印一条包含消息内容及其接受者的消息，然后终止应用程序。</p>
</li>
</ul>
<h2 id="5-8-不要使用-retainCount"><a href="#5-8-不要使用-retainCount" class="headerlink" title="5.8 不要使用 retainCount"></a>5.8 不要使用 retainCount</h2><p><strong>1. retainCount 在反映调用者有多少对象引用，以及调试内存管理都没有任何帮助</strong></p>
<ul>
<li>每个对象都有一个计数器，其表明还有多少个其他对象想令此对象继续存活。在ARC retainCount 这个方法已经废弃了，但是在非ARC 中也不应该调用这个方法，因为这个保留计数只是返回某个时间点的值，并不会联系上下文给出真正有用的值。</li>
</ul>
<p><strong>2. retainCount 在 ARC 环境下将会编译错误</strong></p>
<ul>
<li><p>retainCount 可能永远不返回0，因为系统有时候会优化对象的释放行为，在保留计数为1的时候就把它回收了。</p>
</li>
<li><p>不应该依靠保留计数的具体址来编码。</p>
</li>
<li><p>对象的保留计数看似有用，实则不然，因为任何给定时间点上的 “绝对保留计数”（absolute retain count）都无法反映对象生命期的全貌。</p>
</li>
<li><p>引入ARC 之后，retainCount 方式就正式废止了，在ARC 下调用方法会导致编译器报错。</p>
</li>
</ul>
<p><strong>3. 发布版本时，一定关闭此功能</strong></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/24/iOS-book-EffectiveObjective-C2.0-chap4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yun's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/24/iOS-book-EffectiveObjective-C2.0-chap4/" itemprop="url">
                  EffectiveObjective-C2.0 笔记 - 第四部分
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-09-24 20:11:32" itemprop="dateCreated datePublished" datetime="2018-09-24T20:11:32+08:00">2018-09-24</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2018-11-05 10:03:49" itemprop="dateModified" datetime="2018-11-05T10:03:49+08:00">2018-11-05</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>EffectiveObjective-C2.0 笔记 - 第四部分</strong></p>
<h1 id="4-协议与分类"><a href="#4-协议与分类" class="headerlink" title="4 协议与分类"></a>4 协议与分类</h1><h2 id="4-1-通过委托与数据源协议进行对象间通信"><a href="#4-1-通过委托与数据源协议进行对象间通信" class="headerlink" title="4.1 通过委托与数据源协议进行对象间通信"></a>4.1 通过委托与数据源协议进行对象间通信</h2><p><strong>1. 协议（protocol）类似 java 的接口（interface）。Objective-C 不支持多重继承，但我们可以把某个类应该实现的方法定义在一系列的协议里面。</strong></p>
<ol>
<li>Objective-C 可以使用 “委托模式”（Delegate pattern）的编程设计模式来实现对象间的通信：</li>
</ol>
<blockquote>
<p>定义一套接口，某对象若想接受另一个对象的委托，则需遵从此接口，以便成为其 “委托对象”（delegate）。Objective-C 一般利用 “协议” 机制来实现此模式。</p>
</blockquote>
<p>定义协议：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//采用 “驼峰法” 命名，最后加上 Delegate 一词</span><br><span class="line">@protocol EOCNetworkingFetcherDelegate&lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">// 可选实现的方法</span><br><span class="line">@optional</span><br><span class="line">- (void)newworkingFetcher:(EOCNetworkingFetcher *)fetcher</span><br><span class="line">            didRecevieData:(NSData *)data;</span><br><span class="line"></span><br><span class="line">// 必须实现的方法</span><br><span class="line">@required</span><br><span class="line">- (void)newworkingFetcher:(EOCNetworkingFetcher *)fetcher</span><br><span class="line">         didFailWithError:(NSError *)error;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface EOCNetworkingFetcher : NSObject</span><br><span class="line"></span><br><span class="line">// weak，避免循环引用</span><br><span class="line">@property (nonatomic,weak) id delegate;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p><strong>3. 如果要在委托对象上调用可选方法，那么必须提前使用类型信息查询方法，判断这个委托对象能否响应相关的选择子。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSData *data;</span><br><span class="line">if([_delegate respondsToSelector:@selector(networkFetcher:didRecevieData:)])&#123;</span><br><span class="line">    [_delegate networkFetcher:self didRecevieData:data];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4. delegate 里的方法也可以用于从委托对象中获取信息（数据源模式）。</strong></p>
<p><strong>5. 在实现委托模式和数据源模式的时，协议中的方法是可选的，我们就会写出大量这种判断代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if([_delegate respondsToSelector:@selector(networkFetcher:didRecevieData:)])&#123;</span><br><span class="line">    [_delegate networkFetcher:self didRecevieData:data];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每次调用方法都会判断一次，其实除了第一次检测的结构有用，后续的检测很有可能都是多余的，因为委托对象本身没变，不太可能会一下子不响应，一下子响应的，所以我们这里可以把这个委托对象能否响应某个协议方法记录下来，以优化程序效率。<br>将方法响应能力缓存起来的最佳途径是使用 “位段”（bitfield）数据类型。我们可以把结构体中某个字段所占用的二进制位个数设为特定的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 协议</span><br><span class="line">@protocol EOCNetworkingFetcherDelegate&lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">@optional</span><br><span class="line">- (void) didReceiveData:(NSData *)data;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface EOCNetworkingFetcher ()</span><br><span class="line">// 定义位段</span><br><span class="line">struct &#123;</span><br><span class="line">    unsigned int didReceiveData : 1;</span><br><span class="line">&#125; _delegateFlags</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// 设置</span><br><span class="line">-(void)setDelegate:(id&lt;EOCNetworkingFetcherDelegate&gt;)delegate&#123;</span><br><span class="line">	_delegate = delegate;</span><br><span class="line">	_delegateFlags.didReceiveData = [_delegate respondsToSelector:@selector(didRecevieData:)]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//使用</span><br><span class="line">if(_delageteFlags.didReceiveData)&#123;</span><br><span class="line">	[_delegate didRecevieData:data];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-2-将类的实现代码分散到便于管理的数个分类之中"><a href="#4-2-将类的实现代码分散到便于管理的数个分类之中" class="headerlink" title="4.2 将类的实现代码分散到便于管理的数个分类之中"></a>4.2 将类的实现代码分散到便于管理的数个分类之中</h2><p><strong>1. 使用分类机制把类的实现代码划分成易于管理的小块。</strong></p>
<p><strong>2. 将应该视为 “私有” 的方法归入为叫Private 的分类中，以隐藏实现细节。</strong></p>
<p><strong>3. 分类原则上不能定义属性，当可以通过【关联对象】实现，参见《2.5-关联对象存放自定义数据》</strong></p>
<h2 id="4-3-总是为第三方类的分类名称加前缀"><a href="#4-3-总是为第三方类的分类名称加前缀" class="headerlink" title="4.3 总是为第三方类的分类名称加前缀"></a>4.3 总是为第三方类的分类名称加前缀</h2><p><strong>1. 分类机制常用于向无源码的既有类中新增新功能，但是在使用的时候要十分小心，不然很容易产生Bug。因为这个机制时在运行期系统加载分类时，将其方法直接加到原类中，这里要注意方法重名的问题，不然会覆盖原类中的同名方法。</strong></p>
<p><strong>2. 一般用前缀来区分各个分类的名称与其中所定义的方法。</strong></p>
<p><strong>3. 不要轻易去利用分类来覆盖方法，这里需要慎重考虑。</strong></p>
<h2 id="4-4-勿在分类中声明属性"><a href="#4-4-勿在分类中声明属性" class="headerlink" title="4.4 勿在分类中声明属性"></a>4.4 勿在分类中声明属性</h2><p><strong>1. 可以利用运行期的关联对象机制，为分类声明属性，但是这种做法要尽量避免。</strong></p>
<blockquote>
<p>因为除了 “class-continuation 分类” 之外，其他分类都无法向类中新增实例变量，因此，他们无法把实现属性所需的实例变量合成出来。</p>
</blockquote>
<p><strong>2. 利用关联对象机制可以解决分类中不能合成实例变量的问题。</strong></p>
<blockquote>
<p>自己实现存取方法，但是要注意该属性的内存管理语义（属性特质）。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic,copy) NSString *name;</span><br><span class="line">static const void *kViewControllerName = &amp;kViewControllerName;</span><br><span class="line">- (void)setName:(NSString *)name &#123;</span><br><span class="line">    objc_setAssociatedObject(self, kViewControllerName, name, OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line">- (NSString *)name &#123;</span><br><span class="line">    NSString *myName = objc_getAssociatedObject(self, kViewControllerName);</span><br><span class="line">    return myName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3. 在可以修改源代码的情况下，尽量把属性定义在主接口中。</strong></p>
<blockquote>
<p>这里是唯一能够定义实例变量的地方，属性只是定义实例变量及相关存取方法所用的 “语法糖”。</p>
</blockquote>
<h2 id="4-5-使用-”class-continuation-分类“-隐藏实现细节"><a href="#4-5-使用-”class-continuation-分类“-隐藏实现细节" class="headerlink" title="4.5 使用 ”class-continuation 分类“ 隐藏实现细节"></a>4.5 使用 ”class-continuation 分类“ 隐藏实现细节</h2><p><strong>“class-continuation 分类”必须定义在本身类的实现文件中，而且这里是唯一可以声明实例变量的分类(除关联对象机制)。</strong></p>
<blockquote>
<p>而且此分类没有特定的实现文件，这个分类也没有名字。这里可以定义实例变量的原因是 “ 稳固的ABI” 机制，我们无须知道对象的大小就可以直接使用它。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@interface EOCPerson ()</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p><strong>私有的方法、协议、变量等，都可以定义在“class-continuation 分类”</strong></p>
<p><strong>1. 可以将不需要要暴露给外界知道的实例变量及方法写在 “class-continuation 分类” 中。</strong></p>
<p><strong>2.  可以利用 “class-continuation 分类” 把引用C++ 类的细节写到实现文件中，这样子别的类引用这个类就不会受到影响，甚至都不知道这个类底层实现混有C++ 代码。</strong></p>
<blockquote>
<p>编写Objective-C++ 代码时候，使用 “class-continuation 分类” 会十分方便。因为对于引用了C++的文件的实现文件需要用.mm 为扩展名，表示编译器应该将此文件按照Objective-C++ 来编译。C++ 类必须完全引入，编译器要完整地解析其定义才能得知这个C++ 对象的实例变量大小。如果把对C++ 类的引用写在头文件的话，其他引用到这个类也会引用到这个C++ 类，就也需要编译成Objective-C++ 才行，这样子很容易失控。</p>
</blockquote>
<p><strong>3. 使用 “class-continuation 分类” 还可以将头文件声明 “只读” 的属性扩展成 “可读写”，以便在类的内部可以设置其值。</strong></p>
<blockquote>
<p>我们通常不直接访问实例变量，而是通过设置方法来做，因为这样子可以触发 “键值观测” （Key-Value Observing，KVO）通知。</p>
</blockquote>
<p><strong>4. 若对象所遵循的协议只应视为私有，也可以同过“class-continuation 分类” 来隐藏。</strong></p>
<h2 id="4-6-通过协议提供匿名对象"><a href="#4-6-通过协议提供匿名对象" class="headerlink" title="4.6 通过协议提供匿名对象"></a>4.6 通过协议提供匿名对象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic,weak) id delegate;</span><br></pre></td></tr></table></figure>
<p>该属性类型是id的，所以实际上任何类的都能充当这一属性，即便该类不继承NSObject 也可以，只要遵循EOCDelegae 协议就可以了，对于具备此属性的类来说，delegate 就是 “匿名的”。</p>
<p><strong>1. 使用匿名对象来隐藏类型名称（或类名）。</strong></p>
<p><strong>2. 如果具体类型不重要，重要的是对象能够响应（定义在协议里的）特定方法，那么可使用匿名对象来表示。</strong></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/20/iOS-book-EffectiveObjective-C2.0-chap3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yun's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/20/iOS-book-EffectiveObjective-C2.0-chap3/" itemprop="url">
                  EffectiveObjective-C2.0 笔记 - 第三部分
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-09-20 14:12:31" itemprop="dateCreated datePublished" datetime="2018-09-20T14:12:31+08:00">2018-09-20</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2018-11-05 10:03:49" itemprop="dateModified" datetime="2018-11-05T10:03:49+08:00">2018-11-05</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>EffectiveObjective-C2.0 笔记 - 第三部分</strong></p>
<h1 id="3-接口与-API-设计"><a href="#3-接口与-API-设计" class="headerlink" title="3 接口与 API 设计"></a>3 接口与 API 设计</h1><h2 id="3-1-用前缀避免命名空间冲突"><a href="#3-1-用前缀避免命名空间冲突" class="headerlink" title="3.1 用前缀避免命名空间冲突"></a>3.1 用前缀避免命名空间冲突</h2><p><strong>1.如果发生命名冲突（naming clash），那么应用程序的链接过程就会出错，因为出现了重复符号(duplicate symbol)。</strong></p>
<p><strong>2.应该为所有名称都加上适当的前缀，最好是</strong>++三个字母以上++<strong>做前缀，因为Apple宣称其保留使用所有 “两字母前缀”。</strong></p>
<p><strong>3.在类的实现文件所有的纯C 函数及全局变量，也是容易命名冲突的，在编译好的目标文件中，这些要算做 “顶级符号”（top-level symbol）。</strong></p>
<h2 id="3-2-提供-“全能初始化方法”"><a href="#3-2-提供-“全能初始化方法”" class="headerlink" title="3.2 提供 “全能初始化方法”"></a>3.2 提供 “全能初始化方法”</h2><p><strong>1.“全能初始化方法”（designated initializer）：为对象提供必要信息以便其能完成工作的初始化方法。</strong></p>
<p><strong>2.每个子类的全能初始化方法都应该调用其超类的对应方法，并逐层向上。</strong></p>
<ul>
<li>在类中提供一个全能初始化方法，并于文档里指明。其他初始化方法均应调用此方法。</li>
<li>若全能初始化方法与超类不同，则需覆写超类中的对应方法。</li>
<li>如果超类的初始化方法不适用于子类，那么应该覆写这个超类方法，并在其中抛出异常。</li>
</ul>
<h2 id="3-3-实现-description-方法"><a href="#3-3-实现-description-方法" class="headerlink" title="3.3 实现 description 方法"></a>3.3 实现 description 方法</h2><p><strong>1.在调用NSLog(@”object = %@”,onbject); 其实是调用了对象的description 方法。</strong></p>
<p><strong>2.在我们自定义类中，这样子打印输出信息有可能是这种object =，这个我们需要重写description 方法，让它返回我们需要的一些信息。</strong></p>
<p><strong>3.description 定义在NSObject 协议里面，因为NSObject 不是唯一的 “根类”，用继承不能很好的让其他类有这个方法</strong></p>
<blockquote>
<p>例如：NSProxy 也是遵从了NSObject 协议的 “根类”。</p>
</blockquote>
<p><strong>4.debugDescription 方法是开发者在调试器中以控制台命令打印对象时才调用的，默认是直接调用description 方法。</strong></p>
<p><strong>5.小技巧：可以在description 中用NSDictionary 的description 方法来输出，就是将信息用字典的形式来展示，这样子更加直观，也更加容易扩展。</strong></p>
<h2 id="3-4-尽量使用不可变对象"><a href="#3-4-尽量使用不可变对象" class="headerlink" title="3.4 尽量使用不可变对象"></a>3.4 尽量使用不可变对象</h2><p><strong>1.设计类的时候，用属性来封装数据，在用属性的时候，可将其声明为 “只读” ，避免外部不必要的修改</strong></p>
<blockquote>
<p>PS：如果把可变对象放到collection 之后又修改其内容，很容易会破坏set 的内部数据结构，使其失去固有的语义。</p>
</blockquote>
<p><strong>2.尽量把对外公布出来的属性设为只读，而且只在确有必要时才将属性对外公布。</strong></p>
<p><strong>3.当我们想外部暴露只读属性、内部需要修改属性，这样子通常是在内部将readonly 属性重新声明为readwrite。但是如果该属性是nonatomic 的，这样子做可能会产生 “竞争条件”（rece condition）。在对象内部写入某属性时，对象外的观察者也许正在读取该属性。若想避免此问题，我们可以在必要时通过 “派发队列”（dispatch queue）等手段，将所有的数据存取操作都设为同步操作。</strong></p>
<p><strong>4.虽然属性对外设置成readonly 了，但是外部仍能通过 “键值编码”（Key-Value Coding，KVC）技术设置这些属性值。[object setValue:@”abc” forKey:@”name”] ，这样子可以修改name 这个属性，KVC 会在类中查找 “setName：” 方法来修改属性值。</strong></p>
<p><strong>5.还可以通过类型信息查询功能，查出属性所对应的实例变量在内存中的偏移量，从此来人为设置这个实例变量的值。</strong></p>
<p><strong>注意点总结：</strong></p>
<ul>
<li>尽量创建不可变的对象。</li>
<li>若某属性仅可于对象内部修改，则在 “class-continuation 分类” 中将其由readonly 属性扩展成readwrite 属性。</li>
<li>不要把可变的collection 作为属性公开，而应提供相关方法，以此修改对象中的可变collection。</li>
</ul>
<h2 id="3-5-使用清晰而协调的命名方式"><a href="#3-5-使用清晰而协调的命名方式" class="headerlink" title="3.5 使用清晰而协调的命名方式"></a>3.5 使用清晰而协调的命名方式</h2><h3 id="1、方法与变量命名"><a href="#1、方法与变量命名" class="headerlink" title="1、方法与变量命名"></a>1、方法与变量命名</h3><p><strong>方法和变量名使用 “驼峰式大小写命名法”：以小写字母开头，其后每个单词首字母大写。</strong></p>
<p><strong>1.方法名言简意赅，能准确表达方法功能，不易太长。</strong></p>
<p><strong>2. 如果方法的返回值是新创建的，那么方法名的首个词应该是返回值的类型</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- stringWithString</span><br><span class="line"></span><br><span class="line">- intValue</span><br></pre></td></tr></table></figure>
<p><strong>除非前面还有修饰语，例如localizedString。属性的存取方法不遵循这种命名方式。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- localizedStringWithFormat:</span><br><span class="line"></span><br><span class="line">- initWith</span><br></pre></td></tr></table></figure>
<p><strong>3. 不要使用str这种简称，应该使用string 这样的全称。</strong></p>
<p><strong>4. Boolean 属性应加is前缀。如果某方法返回非属性的Boolean 值，那么应该根据其功能，选用has 或is 当前缀。</strong></p>
<p><strong>5. 将get 这个前缀留给那些借由 ”输出参数“ 来保存返回值的方法，比如说，把返回值填充到 ”C语言式数组“ 里的那种方法就可以使用这个词做前缀。</strong></p>
<h3 id="2、类与协议的命名"><a href="#2、类与协议的命名" class="headerlink" title="2、类与协议的命名"></a>2、类与协议的命名</h3><p><strong>1. 类名也采用驼峰式命名法，不过其首字母需要大写，通常还会加三个以上前缀字母，避免命名空间冲突。</strong></p>
<p><strong>2. 命名应该协调一致，从其他框架继承子类，务必遵循其命名惯例。</strong></p>
<blockquote>
<p>UIView 子类末尾必须是View，委托协议末尾必须是Delegate。</p>
</blockquote>
<p><strong>3. 起名时应遵从标准的Objective-C 命名规范，这样子创建出来的接口更容易为开发者所理解。</strong></p>
<h2 id="3-6-为私有方法名加前缀"><a href="#3-6-为私有方法名加前缀" class="headerlink" title="3.6 为私有方法名加前缀"></a>3.6 为私有方法名加前缀</h2><p><strong>1. 给私有方法的名称加上前缀，这样可以很容易地将其同公共方法区分开。</strong></p>
<blockquote>
<p>一种方案是加前缀 p_</p>
</blockquote>
<p><strong>2. 不要单用一个下划线做私有方法的前缀，因为这种做法是预留给苹果公司用的。</strong></p>
<h3 id="3-7-理解Objective-C-错误模型"><a href="#3-7-理解Objective-C-错误模型" class="headerlink" title="3.7 理解Objective-C 错误模型"></a>3.7 理解Objective-C 错误模型</h3><p><strong>1. ARC 默认不是 “异常安全的”，如果抛出异常，那么应在作用域末尾释放的对象现在却不会自动释放了。</strong></p>
<blockquote>
<p>想要生成 “异常安全的” 代码，可以设置编译器的标志来实现 “-fobjc-arc-exceptions”。但是这样没有异常的情况也会执行这些代码。</p>
</blockquote>
<p><strong>2. 平常很难写出在抛出异常时不会导致内存泄漏的代码，Objective-C 语言现在采用的办法是：只在极其罕见的情况下抛出异常，抛出异常应用程序直接退出，不考虑修复问题，不用再写复杂的 “异常安全” 代码。</strong></p>
<p><strong>3. 只有发生了可使整个应用程序崩溃的严重错误时，才应使用异常。</strong></p>
<p><strong>4. 在 “不那么严重的错误”，令方法返回nil/0，或者是使用NSError，表明其中有错误发生。</strong></p>
<blockquote>
<p>创建对象时，可用 返回nil/0/-1</p>
</blockquote>
<blockquote>
<p>方法逻辑错误或者需要详细错误信息时，考虑 NSError</p>
</blockquote>
<p><strong>5. NSError 可以经由此对象，把导致错误的原因回报给调用者。</strong></p>
<p><strong>NSError 可封装3条信息：</strong></p>
<ul>
<li>Error domain （错误范围，其类型为字符串）</li>
<li>Error code （错误码，其类型为整数）</li>
<li>User info （用户信息，其类型为字典）</li>
</ul>
<p><strong>1）通过委托协议（delegate）来传递NSError</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void) connection:(NSURLConnection *)connection didFailWithError:(NSError *)error;</span><br></pre></td></tr></table></figure>
<p><strong>2）经由方法的 “输出参数” 返回给调用者</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 方法定义</span><br><span class="line">// 返回 BOOL，容易判断（不需要查询 error 参数）。</span><br><span class="line">// NSError ** 为指向指针（NSError *）的指针</span><br><span class="line">- (BOOL) doSomething:(NSError **)error &#123;</span><br><span class="line">  if(/*there was an error*/)&#123;</span><br><span class="line">   // error 参数不是nil,不然解引用异常</span><br><span class="line">   if(error)&#123;</span><br><span class="line">         // *error 解引用，即NSError *指针指向新对象。</span><br><span class="line">         *error = [NSError errorWithDomain:domain</span><br><span class="line">                                      code:code</span><br><span class="line">                                  userInfo:userInfo];</span><br><span class="line">           return NO;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">      return YES;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 用法</span><br><span class="line">NSError *error = nil; // 如果想获取 eroor 详情，不能为 nil</span><br><span class="line">BOOL ret = [objecr doSomething:&amp;error]</span><br><span class="line">if(ret)&#123;</span><br><span class="line">    //to do</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-9-理解NSCopying-协议"><a href="#3-9-理解NSCopying-协议" class="headerlink" title="3.9 理解NSCopying 协议"></a>3.9 理解NSCopying 协议</h2><p><strong>1. 使用对象经常需要拷贝它，此操作通过copy 方法完成。如果想令自己的类支持拷贝操作，那就实现NSCopying 协议，该协议只有一个方法：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (id)copyWithZone:(NSZone *)zone</span><br></pre></td></tr></table></figure>
<p>不必担心zone参数</p>
<blockquote>
<p>以前开发程序，会把内存分成不同的 “区”（zone），而对象会创建在不同区里面，现在不用了，每个程序只有一个区：“默认区”（default zone）。因此不必担心 zone 参数</p>
</blockquote>
<p><strong>2. NSMutableCopying 协议跟NSCopying 类似，也只有一个方法：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (id)mutableCopyWithZone:(NSZone *)zone</span><br></pre></td></tr></table></figure>
<p><strong>3. 如果你的类分可变版本与不可变版本，这两个协议你都应该实现。</strong></p>
<p><strong>4. 注意：在可变对象上调用copy 方法返回另外一个不可变类的实例。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- [NSMutablArray copy] =&gt; NSArray</span><br><span class="line">- [NSArray mutableCopy] =&gt; NSmutableArray</span><br></pre></td></tr></table></figure>
<p><strong>5. 在编写拷贝方法时，还要确定一个问题：应该执行 “深拷贝”（deep copy）还是 “浅拷贝”（shallow copy）。</strong></p>
<p><strong>6. 深拷贝是指在拷贝对象自身时，将其底层的数据也一并复制过去；浅拷贝只对拷贝对象的指针，并不会拷贝底层的数据。Foundation 框架中的所有collection 类默认都执行浅拷贝。</strong></p>
<p><strong>7. 没有专门定义深拷贝的协议，所以具体执行方式由每个类来确定。另外不要假设遵从了NSCopying 协议的对象都会执行深拷贝。绝大多数情况下，执行的都是浅拷贝。</strong></p>
<p><strong>8. 如果你所写的对象需要深拷贝，那么可以考虑新增一个专门执行深拷贝的方法。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (id)initWithSet:(NSArray *)array copyItems:(BOOL)copyItems</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/13/hackintosh-summary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yun's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/13/hackintosh-summary/" itemprop="url">
                  Hackintosh 黑苹果总结
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-09-13 18:22:42" itemprop="dateCreated datePublished" datetime="2018-09-13T18:22:42+08:00">2018-09-13</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2018-09-26 17:21:34" itemprop="dateModified" datetime="2018-09-26T17:21:34+08:00">2018-09-26</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Hackintosh/" itemprop="url" rel="index"><span itemprop="name">Hackintosh</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Hackintosh-黑苹果总结"><a href="#Hackintosh-黑苹果总结" class="headerlink" title="Hackintosh 黑苹果总结"></a>Hackintosh 黑苹果总结</h1><blockquote>
<p>个人用黑苹果开发iOS、java已经有2年多。之所以选择黑苹果，还是因为 Macbook 性能太弱，而且发热严重。2年之久，基本随着 Mac系统更新，也会更新系统（不然无法更新最新的Xcode，纯 java 开发倒是无所谓）。只有一次打开【文件保险箱】功能挂了（下面有说明，千万不要打开该选项），其他时候都没问题。分享其中的一些经验，给愿意尝试黑苹果的朋友。</p>
</blockquote>
<ul>
<li><p>个人黑苹果电脑的配置：</p>
<p>  电脑一：台式机（i7-87000k 华擎 Z370M-ITX 16G GT750ti）</p>
<p>  电脑二：台式机（i5-4590 华硕 b85m 8G）</p>
<p>  电脑三：联想 Y700笔记本（i5-6300 8G GT960M）</p>
</li>
<li><p>帮人配的电脑：</p>
<p>  电脑一：台式机（i7-77000 华擎 deskmini 16G）</p>
<p>  电脑二：台式机（i5-7500 华硕 B150 8G）</p>
<p>  <a href="https://github.com/yunWJR/Hackintosh_List" target="_blank" rel="noopener">EIF 分享-包括以上提到的几种配置机型</a></p>
</li>
</ul>
<h2 id="一、哪些电脑可以安装黑苹果"><a href="#一、哪些电脑可以安装黑苹果" class="headerlink" title="一、哪些电脑可以安装黑苹果"></a>一、哪些电脑可以安装黑苹果</h2><h3 id="1、笔记本"><a href="#1、笔记本" class="headerlink" title="1、笔记本"></a>1、笔记本</h3><p>如何确定笔记本可以安装：</p>
<p>1）搜索笔记本型号，看有安装成功的案例没。</p>
<p>2）看CPU，如果 CPU 的型号与苹果已经发布的笔记本相同或类似（类似定义为同代 CPU），那么 CPU 应该没问题。</p>
<p>3）看显卡：如果笔记本有独显，那么独显基本是不能使用的，只能使用集显。偶尔少数笔记本有独显，主板不能屏蔽独显，导致无法安装。</p>
<p>4）以上满足的话，可以尝试安装。</p>
<h3 id="2、台式机"><a href="#2、台式机" class="headerlink" title="2、台式机"></a>2、台式机</h3><p>如何确定台式机可以安装：</p>
<p>1）搜索台式机配置，看有安装成功的案例没。</p>
<p>2）看CPU，如果CPU的型号与苹果已经发布的笔记本相同或类似（类似定义为同代 CPU），那么 CPU 应该没问题，基本都常见的 intel 台式机 CPU 都可以安装。最新的 AMD 都 CPU 也有大神放出内核，可以安装。</p>
<p>3）看显卡：如果有独显，比较新的 AMD 显卡都可以支持，N 卡一般也支持，有 WebDriver。</p>
<p>4）主板：一般都支持，技嘉的一般支持原生电源管理，比较好。华擎的支持比较到位，曾经几块主板专门出过安装黑苹果的 BIOS，良心。</p>
<p>5）网卡：一般 intel 的有线网卡都支持，无线的话，选择 苹果采用的型号，容易驱动。</p>
<h3 id="3、建议"><a href="#3、建议" class="headerlink" title="3、建议"></a>3、建议</h3><p>1）如果买新电脑</p>
<p>笔记本可以买没有独显的，因为有也一版用不上。先查下哪些比较好安装的机型，照着买就行。</p>
<p>台式机可以参考 <a href="https://www.tonymacx86.com/buyersguide/building-a-customac-hackintosh-the-ultimate-buyers-guide/" target="_blank" rel="noopener">tonymacx86</a>上的配置，都很容易安装。</p>
<p>2）最好配2块以上硬盘。</p>
<p>一块安装 Mac。另外一块安装 Windows，或者作为备份盘（TimeMachine）。如果作为生成环境使用，建议单独配置一块硬盘作为 TimeMachine 的备份盘。</p>
<p>3）如果要独显，最好选 AMD 的卡，可以很好的原生驱动。</p>
<p>4）如果配无线，最好选 Mac 电脑上用过的型号，容易驱动。</p>
<h2 id="二、安装流程"><a href="#二、安装流程" class="headerlink" title="二、安装流程"></a>二、安装流程</h2><h3 id="最简方式："><a href="#最简方式：" class="headerlink" title="最简方式："></a>最简方式：</h3><p>1、Mac 上 AppStore 中下载 Mac 系统</p>
<p>2、制作安装镜像到 U 盘，可以借助工具 <a href="http://diskmakerx.com/" target="_blank" rel="noopener">DiskMaker</a></p>
<p>3、制作 EFI 启动分区，可以制作在 U 盘上，也可以制作在硬盘上。</p>
<p>4、放入 EFI 分区启动文件（kext 和 config 配置文件等）</p>
<p>5、设置好 BIOS 选项</p>
<p>6、从 EFI 启动安装</p>
<p>7、完善安装（各硬件驱动）</p>
<p>8、完善 EFI，可将稳定的 EIF 文件，放入 Mac 分区的 EFI 分区。从 Mac 分区启动。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>1、不要随意升级 Mac 新版本，可能造成 kext 不兼容。</p>
<p>2、最好配一块备份盘，用 TimeMachine 备份。TimeMachine 确实好用。</p>
<p>3、一般不要去动 SLE 下的系统kext，也尽量不要把 kext 放入 SLE 下面，补丁 kext 都可以放在 EFI 下的 kext 中调试。</p>
<p>4、千万不要打开『安全与隐私』中的 【<strong>文件保险箱</strong>】功能，该功能与硬件相关，打开后，黑苹果就GG。</p>
<p>5、config 中的硬件 ID 尽量用同一个（同一台机子），新机子第一次安装时，随机生成一个。频繁更改 ID，会让你重新登录 AppleId。</p>
<h3 id="可以参考的网站"><a href="#可以参考的网站" class="headerlink" title="可以参考的网站"></a>可以参考的网站</h3><p><a href="https://www.tonymacx86.com/" target="_blank" rel="noopener">tonymacx86 - 国外很活跃度黑苹果网站，还有配置推荐</a></p>
<p><a href="http://bbs.pcbeta.com/forum.php?mod=forumdisplay&amp;fid=558&amp;filter=author&amp;orderby=dateline" target="_blank" rel="noopener">pcbeta - 国内活跃度黑苹果网站</a></p>
<p><a href="https://sourceforge.net/projects/cloverefiboot/" target="_blank" rel="noopener">cloverefiboot - clover项目现在地址</a></p>
<p><a href="https://bitbucket.org/RehabMan/" target="_blank" rel="noopener">RehabMan bitbucket -  RehabMan的 kext下载</a></p>
<p><a href="https://github.com/RehabMan" target="_blank" rel="noopener">RehabMan git - RehabMan的 kext下载和一些配置信息</a></p>
<p><a href="https://github.com/acidanthera" target="_blank" rel="noopener">acidanthera git - 作者写了很多有用的 kext</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/11/springcloud-summary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yun's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/11/springcloud-summary/" itemprop="url">
                  SpringCloud 概述
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-08-11 20:41:32" itemprop="dateCreated datePublished" datetime="2018-08-11T20:41:32+08:00">2018-08-11</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2018-11-05 10:03:49" itemprop="dateModified" datetime="2018-11-05T10:03:49+08:00">2018-11-05</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/SpringCloud/" itemprop="url" rel="index"><span itemprop="name">SpringCloud</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="SpringCloud-概述"><a href="#SpringCloud-概述" class="headerlink" title="SpringCloud 概述"></a>SpringCloud 概述</h1><h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><p>微服务是一个小的、松耦合的分布式服务。</p>
<h3 id="1、微服务的基础问题"><a href="#1、微服务的基础问题" class="headerlink" title="1、微服务的基础问题"></a>1、微服务的基础问题</h3><blockquote>
<p>服务粒度</p>
</blockquote>
<ul>
<li>服务职责单一</li>
<li>服务无状态话</li>
<li>操作表不能太多（3-5个）</li>
<li>避免简单的 CRUD服务</li>
</ul>
<blockquote>
<p>通信协议</p>
</blockquote>
<blockquote>
<p>接口设计</p>
</blockquote>
<ul>
<li>RESTful 风格接口</li>
<li>内容使用 JSON</li>
<li>HTTP 状态码表示结果</li>
</ul>
<blockquote>
<p>服务的配置管理 – Config</p>
</blockquote>
<pre><code>统一配置服务器，避免配置与服务硬绑定。
</code></pre><blockquote>
<p>服务之间的事件处理 – Stream</p>
</blockquote>
<pre><code>使用事件解耦微服务，最小化服务之间的硬编码依赖。
</code></pre><h3 id="2、微服务路由模式"><a href="#2、微服务路由模式" class="headerlink" title="2、微服务路由模式"></a>2、微服务路由模式</h3><p>负责处理客服端的服务请求，使其到达特定实例。</p>
<blockquote>
<p>服务路由（网关） – Netflix Zuul</p>
</blockquote>
<pre><code>为所有服务提供单个入口点，可整合安全策略、路由规则等。
</code></pre><blockquote>
<p>服务发现 – Netflix Eureka</p>
</blockquote>
<pre><code>微服务注册中心、管理服务。
</code></pre><h3 id="3、客服端弹性模式"><a href="#3、客服端弹性模式" class="headerlink" title="3、客服端弹性模式"></a>3、客服端弹性模式</h3><p>避免单个服务影响整个系统，提高服务稳定性。</p>
<blockquote>
<p>客服端负载均衡 – Neflix Ribbon</p>
</blockquote>
<pre><code>负载均衡，避免单个服务过载
</code></pre><blockquote>
<p>断路器模式 – Netflix Hystrix</p>
</blockquote>
<pre><code>阻止客户继续调用出故障/有性能问题的服务
</code></pre><blockquote>
<p>后备模式 – Netflix Hystrix</p>
</blockquote>
<pre><code>服务调用失败后，提供后备方案
</code></pre><blockquote>
<p>舱壁模式 – Netflix Hystrix</p>
</blockquote>
<pre><code>避免个别微服务故障影响整个服务。
</code></pre><h3 id="4、微服务安全"><a href="#4、微服务安全" class="headerlink" title="4、微服务安全"></a>4、微服务安全</h3><blockquote>
<p>验证 – Security/OAuth2</p>
</blockquote>
<pre><code>身份验证
</code></pre><blockquote>
<p>授权 – Security/OAuth2</p>
</blockquote>
<pre><code>权限验证
</code></pre><blockquote>
<p>凭据管理和传播  – Security/OAuth2 JWT</p>
</blockquote>
<pre><code>验证的模式 -JWT
</code></pre><h3 id="5、微服务日志记录与跟踪模式"><a href="#5、微服务日志记录与跟踪模式" class="headerlink" title="5、微服务日志记录与跟踪模式"></a>5、微服务日志记录与跟踪模式</h3><blockquote>
<p>日志关联 – Sleuth</p>
</blockquote>
<pre><code>关联请求在所有微服务中的调用链。
</code></pre><blockquote>
<p>日志聚合 – Sleuth、Papertrail</p>
</blockquote>
<pre><code>将所有微服务的日志聚合到一起
</code></pre><blockquote>
<p>微服务跟踪 – Sleuth/Zipkin</p>
</blockquote>
<pre><code>跟踪微服务的事物流程，以及其性能。
</code></pre><h3 id="6、微服务构建和部署"><a href="#6、微服务构建和部署" class="headerlink" title="6、微服务构建和部署"></a>6、微服务构建和部署</h3><blockquote>
<p>构建和部署管道</p>
</blockquote>
<pre><code>可重复的构建和部署过程。
</code></pre><blockquote>
<p>基础设施即代码</p>
</blockquote>
<blockquote>
<p>不可变服务器</p>
</blockquote>
<pre><code>部署之后永远不会改变
</code></pre><blockquote>
<p>凤凰服务器（Phoenix server）</p>
</blockquote>
<pre><code>服务长期一致性。
</code></pre>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/18/iOS-book-EffectiveObjective-C2.0-chap2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yun's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/18/iOS-book-EffectiveObjective-C2.0-chap2/" itemprop="url">
                  EffectiveObjective-C2.0 笔记 - 第二部分
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-06-18 11:22:23" itemprop="dateCreated datePublished" datetime="2018-06-18T11:22:23+08:00">2018-06-18</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2018-10-10 17:03:19" itemprop="dateModified" datetime="2018-10-10T17:03:19+08:00">2018-10-10</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>EffectiveObjective-C2.0 笔记 - 第二部分</strong></p>
<h1 id="2-1-属性"><a href="#2-1-属性" class="headerlink" title="2.1 属性"></a>2.1 属性</h1><p><strong>1. “对象”（object）就是 “基本构造单元”（building block），开发者可以通过对象来存储并传递数据。</strong></p>
<blockquote>
<p>在对象直接传递数据并执行任务的过程就叫做 “消息传递”（Messaging）。</p>
</blockquote>
<p><strong>2. 程序运行起来后，为其提供相关支持的代码叫做”运行期环境”(runtime)，它提供一些使得对象之间能够传递消息的重要函数。</strong></p>
<blockquote>
<p>理解运行期环境，可以帮你写出高效且易维护的代码。 </p>
</blockquote>
<p><strong>3. Oc编译采用“应用程序二进制接口”（Application Binary Interface，ABI）</strong></p>
<blockquote>
<p>把实例变量当作一种存储偏移量所用的 “特殊变量”（speacial variable），交由 “类对象”（class object）保管。偏移量会在运行期查找，这样子总能找到正确的偏移量，这是稳固。</p>
</blockquote>
<blockquote>
<p>如果对象布局在编译器就固定了，访问变量时，编译器会使用 “偏移量”（offset）来计算，这个偏移量是 “硬编码”（hardcode），表示该变量距离存放对象的内存区域的起始地址有多远。 存在一个问题：如果代码使用了编译期计算出来的偏移量，那么修改类定义之后必须重新编译，否则就会出错。</p>
</blockquote>
<h3 id="property"><a href="#property" class="headerlink" title="@property"></a>@property</h3><p><strong>1. 用于声明属性，自动添加实例变量，以下划线开头，自动实现属性的读写方法。</strong></p>
<p><strong>2. 在实现文件中可以通过@synthesize 语法来指定实例变量的名字</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@implementation EOCPerson</span><br><span class="line">@synthesize name = _myName;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p><strong>3. @dynamic 关键字会告诉编译器：不要自动创建实现属性所用的实例变量，也不要为其创建存取方法</strong></p>
<h2 id="属性特质"><a href="#属性特质" class="headerlink" title="属性特质"></a>属性特质</h2><p>原子性、读写权限、内存管理语义、方法名、其他。</p>
<h3 id="1、原子性"><a href="#1、原子性" class="headerlink" title="1、原子性"></a>1、原子性</h3><ul>
<li><p><strong>atomic -默认</strong></p>
<ul>
<li>原子性，会生成读写锁，读写安全（线程不一定安全），占用资源、效率一般。</li>
</ul>
</li>
<li><p><strong>nonatomic</strong> </p>
<ul>
<li>非原子、效率高、读写不安全</li>
</ul>
</li>
</ul>
<h3 id="2、读写权限"><a href="#2、读写权限" class="headerlink" title="2、读写权限"></a>2、读写权限</h3><ul>
<li><p><strong>readwrite -默认</strong></p>
<ul>
<li>读写</li>
</ul>
</li>
<li><p><strong>readonly</strong> </p>
<ul>
<li>只读</li>
</ul>
</li>
</ul>
<h3 id="3、内存管理"><a href="#3、内存管理" class="headerlink" title="3、内存管理"></a>3、内存管理</h3><p>MRC时，有assign、retain、copy，ARC加入了strong、weak</p>
<ul>
<li><p><strong>assign -值类型默认</strong></p>
<ul>
<li>简单赋值、用于值类型，如CGFloat、NSInteger等</li>
</ul>
</li>
<li><p><strong>strong (同retain -MRC) -引用类型默认</strong></p>
<ul>
<li><p>强引用、用于引用类型</p>
</li>
<li><p>赋值时，保留新值，新值引用计数+1，释放旧值（引用计数-1）。</p>
</li>
<li><p>用于所有的实例变量和局部变量、其他常规对象引用。</p>
</li>
<li><p>注意：可变对象应该使用strong，如NSMultiString，NSMultiArray</p>
</li>
</ul>
</li>
<li><p><strong>copy</strong> </p>
<ul>
<li><p>复制、用于引用类型</p>
</li>
<li><p>赋值时，拷贝新值（新对象引用计数为1），释放旧值（引用计数-1），不改变新值（引用计数不变）。</p>
</li>
<li><p>copy的本质为复制该内存所存储的内容，重新创建一个对象赋给其相同的内容，对于实现了NSCopying协议的对象有效。</p>
</li>
<li><p>用于不可变对象：NSString、block、NSArray、NSDictionary等</p>
</li>
<li><p>注意：用于可变对象时，设置值后，变为不可变对象</p>
</li>
</ul>
</li>
<li><p><strong>weak</strong> </p>
<ul>
<li><p>弱引用、用于引用类型</p>
</li>
<li><p>赋值时、单纯的引用新对象地址，不改变新对象（引用计数不变），不改变旧对象（引用计数不变）</p>
</li>
<li><p>当引用对象释放后，其值置为nil</p>
</li>
</ul>
</li>
<li><p><strong>__unsafe_unretained</strong> </p>
<ul>
<li><p>类似assign、适用于引用类型、不安全的弱引用</p>
</li>
<li><p>功能类似于weak、对象摧毁后，不置nil、不安全，可用weak代替</p>
</li>
</ul>
</li>
</ul>
<h3 id="4、方法名"><a href="#4、方法名" class="headerlink" title="4、方法名"></a>4、方法名</h3><ul>
<li><p><strong>getter = methodname</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, getter = isOn) BOOL on;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>setter = methodname</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, setter = setOnState) BOOL on;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="5、其他"><a href="#5、其他" class="headerlink" title="5、其他"></a>5、其他</h3><p>nonnull, null_resettable, nullable</p>
<h1 id="2-2-对象访问"><a href="#2-2-对象访问" class="headerlink" title="2.2 对象访问"></a>2.2 对象访问</h1><p><strong>1. 对象访问有两种、一种是实例访问、一种是属性的读写方法访问。</strong></p>
<ul>
<li><p>一般可以这样做：读取时，通过实例读取、写入时，通过属性方法写入。初始化时，都用实例。</p>
</li>
<li><p>一般外部访问时，通过属性访问。</p>
</li>
<li><p>内部访问时、无特殊情况，通过实例访问。</p>
</li>
</ul>
<p><strong>2. 具体情况应该根据他们的特点来定：</strong></p>
<ul>
<li><p>实例访问不通过属性方法派发、效率高。</p>
</li>
<li><p>实例访问、不触发“键值观测”，无法满足某些场景。</p>
</li>
<li><p>初始化方法中，尽量实例访问，避免子类重写设置方法，导致出错。</p>
</li>
<li><p>如果待初始化的实例声明在超类中，而我们又无法在子类直接访问此实例变量的话，那么就需要调用 “设置方法” 了。</p>
</li>
<li><p>在 “惰性初始化”（lazy initialization），必须通过 “获取方法” 来访问属性，不然实例变量永远不会初始化。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-(EOCBrain *)brain&#123;</span><br><span class="line">    if(!_brain)&#123;</span><br><span class="line">        _brain = [EOCBrain new];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return _brain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="2-3-对象同等性"><a href="#2-3-对象同等性" class="headerlink" title="2.3 对象同等性"></a>2.3 对象同等性</h1><p><strong>1. == 与 isEqual</strong></p>
<ul>
<li><p><strong>==</strong></p>
<ul>
<li><p>== 用于值对象时，可以直接判断值是否相等。</p>
</li>
<li><p>== 用于引用对象时，是判断两个对象的指针是否相等（为同一个对象），不能判断其内容等同。</p>
</li>
</ul>
</li>
<li><p><strong>isEqual</strong> </p>
<ul>
<li>用于引用类型、判断内容是否等同、常需要ovewrite该方法。</li>
</ul>
</li>
</ul>
<p><strong>2. NSObject 协议中有两个用于判断等同性的关键方法：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)isEqual:(id)object;</span><br><span class="line">- (NSUInteger)hash;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>如果 “isEqual” 方法判定两个对象相等，那么其hash 方法也必须返回同一个值。</p>
</li>
<li><p>但是，如果两个对象的hash 方法返回同一个值，那么 “isEqual” 方法未必会认为两者相等。</p>
</li>
</ul>
<p><strong>hash方法实现的一些情况：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 1-固定值</span><br><span class="line">- (NSUInteger)hash &#123;</span><br><span class="line">    return 12312312;</span><br><span class="line">&#125;</span><br><span class="line">// 这种会对collection使用这个对象产生性能问题。因为在collection 在检索哈希表的时，会用对象的哈希码来做索引，在set 集合中，会根据哈希码把对象分装到不同的数组里面，在添加新对象的时候，要根据其哈希码找对与之对应的数组，依次检查其中各个元素，看数组已有的对象是否和将要添加的新对象相等，如果相等，就说明添加的对象已经在set 集合中了，是添加失败的。（如果所有对象的hash 值对一样，这样子set 集合只会有一个数组，所有数据都在一起了，每次插入数据都会遍历这个数组，这样子就会出现性能问题）</span><br><span class="line"></span><br><span class="line">// 2-组合值</span><br><span class="line">- (NSUInteger)hash &#123;</span><br><span class="line">    NSString *stringToHash = [NSString stringWithFormat@&quot;%@:%@&quot;,_firstName,_lastNmae];</span><br><span class="line">    return [stringToHash hash];</span><br><span class="line">&#125;</span><br><span class="line">//这样子能在一定情况下保证返回不同的哈希码，但是这里会存在创建字符串的开销，会比返回单一值要慢</span><br><span class="line"></span><br><span class="line">// 3-位运算</span><br><span class="line">- (NSUInteger)hash &#123;</span><br><span class="line">    return [self.firstName hash] ^ [self.lastNmae hash];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ^为逐位逻辑运算符，它表示逐位非或（如果只有一个位为1，那么结果为1；否则为0。）。</span><br><span class="line">//这样子可以保存较高的效率，又不会过于频繁的重复</span><br></pre></td></tr></table></figure>
<p><strong>3. 特定类所具有的等同性判定方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">isEqualToString、isEqualToArray、isEqualToDictionary</span><br></pre></td></tr></table></figure>
<p><strong>4. 容器中可变类的等同性</strong></p>
<ul>
<li>如果要把某个对象放入colloection ，其 hash 方法的生成策略就应该保证在放入colloection 后，hash 值不再改变。不然会出现问题。</li>
</ul>
<h1 id="2-4-类族模式"><a href="#2-4-类族模式" class="headerlink" title="2.4 类族模式"></a>2.4 类族模式</h1><p><strong>1. “类族” （class cluster）是一种很有用的模式（pattern），可以隐藏 “抽象基类” （abstract base class）背后的实现细节。</strong></p>
<p><strong>2. 用户无须自己创建子类实例，只需要调用基类方法来创建即可。</strong></p>
<p><strong>3. 如何创建类族</strong></p>
<ul>
<li><p>每个 “实体子类” 都从基类继承而来，“工厂模式” 是创建类族的办法之一，调用基类方法返回子类实例。</p>
</li>
<li><p>如果对象所属的类位于某个类族中，那么查询其类型信息要注意，你可能觉得自己创建了某个类的实例，然后实际上创建的却是其子类的实例。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-(BOOL) isKindOfClass: classObj; //判断是否是这个类或者这个类的子类的实例</span><br><span class="line">-(BOOL) isMemberOfClass: classObj; //判断是否是这个类的实例</span><br></pre></td></tr></table></figure>
<h1 id="2-5-关联对象存放自定义数据"><a href="#2-5-关联对象存放自定义数据" class="headerlink" title="2.5 关联对象存放自定义数据"></a>2.5 关联对象存放自定义数据</h1><p><strong>1. 关联对象</strong> </p>
<p>可以给某个对象关联许多其他对象，这些对象通过“键”来区分。存储对象值的时候，可以指明“存储策略”，用以维护相应的“内存管理语义”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">OBJC_ASSOCIATION_ASSIGN --- assign</span><br><span class="line">OBJC_ASSOCIATION_RETAIN_NONATOMIC --- nonatomic, retain</span><br><span class="line">OBJC_ASSOCIATION_COPY_NONATOMIC --- nonatomic, copy</span><br><span class="line">OBJC_ASSOCIATION_RETAIN --- retain</span><br><span class="line">OBJC_ASSOCIATION_COPY --- copy</span><br></pre></td></tr></table></figure>
<p>下列方法可以管理关联对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void objc_setAssociatedObject (id object, void *key, id value, objc_AssociationPolicy policy)</span><br><span class="line">// 此方法以给定的键和策略为某对象设置关联对象值</span><br><span class="line"></span><br><span class="line">id objc_getAssociatedObject(id object, void *key) </span><br><span class="line">// 此方法根据给定的键从某个对象中获取相应的关联对象值</span><br><span class="line"></span><br><span class="line">void objc_removeAssociatedObject(id object) </span><br><span class="line">// 此方法移除指定对象的全部关联对象</span><br></pre></td></tr></table></figure>
<p>若想令两个健匹配到相同的一个值，则二者必须是完全相同的指针才行。所以，在设置关联对象值时：<strong>通常使用静态全局变量做键</strong>。</p>
<h1 id="2-6-消息"><a href="#2-6-消息" class="headerlink" title="2.6 消息"></a>2.6 消息</h1><h2 id="一-消息传递（objc-msgSend）"><a href="#一-消息传递（objc-msgSend）" class="headerlink" title="一. 消息传递（objc_msgSend）"></a>一. 消息传递（objc_msgSend）</h2><p><strong>1. 调用对象方法，在Objective-C 中叫做 “传递消息”（pass a message），消息有 “名称”（name）或“选择子”（selector），可以接受参数，而且可能还有返回值。</strong></p>
<p>objc_megSend 的原型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 方法原型</span><br><span class="line">// messageName 叫做 selector（选择子），选择子和参数合起来称为&quot;消息&quot;。</span><br><span class="line">id returnValue = [receiveObject messageName:parameter];</span><br><span class="line"></span><br><span class="line">// 所有方法都是普通的 C 语言函数，方法转为标准的 C 语言函数如下：</span><br><span class="line">// 是一个 “参数个数可变的函数”，能够接受两个或两个以上的参数,</span><br><span class="line">// 第一个参数代表接收者，第二个参数代表选择子，后续参数就是参数。</span><br><span class="line">void objc_msgSend(id self,SEL cmd,...)</span><br></pre></td></tr></table></figure>
<p><strong>2. objc_megSend 函数会依据接收者和选择子来调用适当的方法：</strong></p>
<ul>
<li>在接收者所属的类搜寻其 “方法列表”</li>
<li>找不到的话，就沿着继承体系继续向上查找</li>
<li>最终还是找不到相符的方法就执行 “消息转发”</li>
</ul>
<p><strong>3. 每个类里都有一张函数表，选择子的名称则是表的 “键”，对应的值都是指向函数的指针。objc_msgSend 等函数就是通过这个函数表来寻找应该执行的方法并执行跳转的。</strong></p>
<p><strong>4. objc_msgSend 会将匹配结果缓存在 “快速映射表”（fast map）里面，每个类都有这样子的一块缓存，接下来还向该类发送一样的消息，那么执行起来就很快了。</strong></p>
<p><strong>5. 这里有些特殊情况，需要由Objective-C 运行环境的另外一些函数来处理：</strong></p>
<ul>
<li>objc_msgSend_stret ：如果待发送的消息要返回结构体，那么可以交由此函数处理。只有当CPU 寄存器能够容纳得下消息返回类型时，这个函数才能处理此消息。若是返回值无法容纳于CPU 寄存器（比如说返回的结构体太大了），那么就由另外一个函数执行派发。此时，那个函数会通过分配在栈上的某个变量来处理消息所返回的结构体。</li>
<li>objc_msgSend_fpret：如果消息返回的是浮点数，可以交由此函数处理。这个函数是为了处理x86 等架构CPU 中某些令人惊讶的奇怪状况。</li>
<li>objc_msgSendSuper：如果要给超类发消息，那么就交由此函数处理。</li>
</ul>
<p><strong>6. 如果某函数的最后一项操作是调用另外一个函数，那么就可以运用 “尾调用优化” 技术。编译器会生成跳转至另外一个函数所需的指令码，而且不会向调用栈推入新的 “栈帧”。</strong></p>
<h2 id="二、-消息转发"><a href="#二、-消息转发" class="headerlink" title="二、 消息转发"></a>二、 消息转发</h2><p>当对象接收到无法解读的消息后，就会启动 “消息转发”（message forwarding）机制，程序员可经由此过程告诉对象应该如何处理未知消息。</p>
<p><strong>消息转发分为两大阶段：</strong></p>
<h3 id="1-动态方法解析"><a href="#1-动态方法解析" class="headerlink" title="1. 动态方法解析"></a>1. 动态方法解析</h3><p>第一阶段选征询接收者，所属的类，看其是否能动态添加方法，以处理当前这个 “未知的选择子“（unknown seletor），这叫做 ”动态方法解析“（dynamic method resolution）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//表示这个类是否能新增一个方法来处理此选择子</span><br><span class="line">+ (BOOL)resolveClassMethod:(SEL)sel</span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel</span><br></pre></td></tr></table></figure>
<h3 id="2-完整的消息转发机制"><a href="#2-完整的消息转发机制" class="headerlink" title="2. 完整的消息转发机制"></a>2. 完整的消息转发机制</h3><p>第二阶段涉及 ”完整的消息转发机制“（full forwarding mechanism）。</p>
<blockquote>
<p>如果运行期系统已经把第一阶段执行完了，那么接收者自己就无法再以动态新增方法的手段来响应包含该选择子的消息了。这里的第二阶段又分为下面两小步：</p>
</blockquote>
<ul>
<li><p><strong>1) 备援的接收者</strong></p>
<p>  首先，请接收者看看有没其他对象能处理这条消息；若有，则运行期系统会把消息转给那个对象，于是消息转发过程结束，一切正常。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>2) 若没有 ”备援的接收者“（replacement receiver），则启动完整的消息转发机制。</strong></p>
<p>  运行期系统会把与消息有关的全部细节都封装到NSInvocation 对象中，再给接受者最后一次机会，令其设法解决当前还未处理的这条消息。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation</span><br></pre></td></tr></table></figure>
<h1 id="2-7-方法调配"><a href="#2-7-方法调配" class="headerlink" title="2.7 方法调配"></a>2.7 方法调配</h1><p><strong>1. 不需要源代码，也不需要通过继承子类来覆写方法就能改变这个类本身的功能，新功能在本类的所有实例都生效，此方案称为 “方法调配”（method swizzling）。</strong></p>
<p><strong>2. 每个类有个方法列表（函数指针 IMP），各自映射到自己的方法实现，只要我们能操作这个函数指针的指向，我们就可以动态的增加替换原有的方法。</strong></p>
<p><strong>3. 互换两个已经写好的方法实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 获取方法实现：</span><br><span class="line">Method class_getInstanceMethod(Class cls, SEL name)</span><br><span class="line"></span><br><span class="line">// 调换方法实现</span><br><span class="line">void method_exchangeImplementations(Method m1, Method m2)</span><br></pre></td></tr></table></figure>
<p><strong>4. 为已有方法增加新功能：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Method originalMethod = class_getInstanceMethod(class, originalSelector);</span><br><span class="line">Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);</span><br><span class="line"></span><br><span class="line">BOOL didAddMethod =</span><br><span class="line">class_addMethod(class,</span><br><span class="line">                originalSelector,</span><br><span class="line">                method_getImplementation(swizzledMethod),</span><br><span class="line">                method_getTypeEncoding(swizzledMethod));</span><br><span class="line"></span><br><span class="line">if (didAddMethod) &#123;</span><br><span class="line">    class_replaceMethod(class,</span><br><span class="line">                        swizzledSelector,</span><br><span class="line">                        method_getImplementation(originalMethod),</span><br><span class="line">                        method_getTypeEncoding(originalMethod));</span><br><span class="line">&#125; else &#123;</span><br><span class="line">   method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="2-8-理解-“类对象”-的用意"><a href="#2-8-理解-“类对象”-的用意" class="headerlink" title="2.8 理解 “类对象” 的用意"></a>2.8 理解 “类对象” 的用意</h1><p><strong>1. 每个Objective-C 对象实例都是指向某块内存数据的指针。</strong></p>
<p><strong>2. Objective-C 对象所用的数据结构</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct objc_object &#123;</span><br><span class="line">    Class isa;</span><br><span class="line">&#125;;</span><br><span class="line">/// A pointer to an instance of a class.</span><br><span class="line">typedef struct objc_object *id;</span><br></pre></td></tr></table></figure>
<p>每个对象结构体首个成员是Class 类的变量，定义了对象所属的类，通常称为 “is a” 指针。</p>
<p><strong>3. Class 对象的数据结构定义</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct objc_class &#123;</span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">#if !__OBJC2__</span><br><span class="line">    Class super_class                                        OBJC2_UNAVAILABLE;</span><br><span class="line">    const char *name                                         OBJC2_UNAVAILABLE;</span><br><span class="line">    long version                                             OBJC2_UNAVAILABLE;</span><br><span class="line">    long info                                                OBJC2_UNAVAILABLE;</span><br><span class="line">    long instance_size                                       OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_cache *cache                                 OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;</span><br><span class="line">#endif</span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure>
<p>Class 首个变量也是isa 指针，说明Class 本身也是Objective-C 对象，指向 “元类”（meta class）。</p>
<p><strong>4. 在类继承体系中查询类型信息</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 判断对象是否为某个特定类的实例，不能判定 super 类</span><br><span class="line">isMemberOfClass</span><br><span class="line"></span><br><span class="line">// 判断出对象是否为某类或其派生类的实例</span><br><span class="line">isKindOfClass</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/16/iOS-book-EffectiveObjective-C2.0-chap1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yun's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/16/iOS-book-EffectiveObjective-C2.0-chap1/" itemprop="url">
                  EffectiveObjective-C2.0 笔记 - 第一部分
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-06-16 14:25:22" itemprop="dateCreated datePublished" datetime="2018-06-16T14:25:22+08:00">2018-06-16</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2018-10-10 16:35:43" itemprop="dateModified" datetime="2018-10-10T16:35:43+08:00">2018-10-10</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="EffectiveObjective-C2-0-笔记-第一部分"><a href="#EffectiveObjective-C2-0-笔记-第一部分" class="headerlink" title="EffectiveObjective-C2.0 笔记 - 第一部分"></a>EffectiveObjective-C2.0 笔记 - 第一部分</h1><hr>
<h1 id="1-1-了解Objective-C"><a href="#1-1-了解Objective-C" class="headerlink" title="1.1-了解Objective-C"></a>1.1-了解Objective-C</h1><h2 id="了解Objective-C-语言的起源"><a href="#了解Objective-C-语言的起源" class="headerlink" title="了解Objective-C 语言的起源"></a>了解Objective-C 语言的起源</h2><p><strong>1. Objective-C（以下简称Oc）是在C语言的基础上添加了面向对象特性。</strong></p>
<blockquote>
<p>Oc是C语言的超集（superset），因此C语言的所有功能特性都可以适用于Oc。</p>
</blockquote>
<p><strong>2. Oc是使用“消息结构”（messaging structure)，而非常见的“函数调用”（function calling）。它们区别像这样</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// message structure </span><br><span class="line">Object *obj = [Object new];</span><br><span class="line">[obj performWith:para1 and:para2]</span><br><span class="line"></span><br><span class="line">// 其特性就是“运行时组件（Runtime）”，其本质上就是一种与开发者所编代码相链接的 “动态库”（dynamic libary），其代码能把开发者编写的所有程序粘合起来。</span><br><span class="line">// 运行时所执行的代码由运行环境决定，动态特性明显，但是有些问题编译期间无法发现。</span><br><span class="line">// 所有方法，都是运行时去查找，运行。接收消息的对象也要在运行时去查找。这时候就可能出问题。见后面。</span><br><span class="line"></span><br><span class="line">// functions calling</span><br><span class="line">Object *obj = new Object;</span><br><span class="line">obj-&gt;perform(para1,para2);</span><br><span class="line"></span><br><span class="line">// 与消息型相反，函数方法都有编译器编译的时候实现，可以预先发现一些潜在问题。</span><br><span class="line">// 运行时所执行的代码由编译器决定；</span><br><span class="line">// 如果是多态方法，运行时就会去“虚方法表（virtual table）”查找出具体哪一个函数；</span><br></pre></td></tr></table></figure>
<p><strong>3. Oc中的对象总是分配在“堆空间”（heap space），不会分配到“栈”（stack）上。</strong></p>
<blockquote>
<p>Oc 将堆内存管理抽象出来了，不需要用malloc 及free 来分配或释放对象所占内存，Oc<br>运行期环境把这部分工作抽象成一套内存管理架构，叫 ”引用计数“ 。一个例子</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSString *someString = @&quot;The string&quot;;</span><br><span class="line">NSString *anotherString = someString;</span><br></pre></td></tr></table></figure>
<p><img src="http://ot8psglzx.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20180914225911.png" alt="image"></p>
<p><strong>4. 能用C的结构体，不用对象，结构体比对象更有效率。</strong></p>
<blockquote>
<p>对象要分配空间，释放空间,而结构体不需要。结构体储存在栈空间。</p>
</blockquote>
<p><strong>5. 非对象类型（nonobject type），分配在栈上，在其栈帧弹出时自动清理。</strong></p>
<h1 id="1-2-头文件"><a href="#1-2-头文件" class="headerlink" title="1.2-头文件"></a>1.2-头文件</h1><p><strong>核心点：在类的头文件中尽量少引用其他头文件</strong></p>
<p><strong>1. Oc 中编写类方式与 C和C++一样，使用头文件（header file）、实现文件（implementation file）来区隔代码。</strong></p>
<p><strong>2. 引用其他类，使用@class xxx的向前声明方式（forward declaring）。</strong></p>
<blockquote>
<p>也可以使用#import或#include，但是不够优雅，这里就要知道引用 类的具体细节，这里会引用到引用类的具体实现，会增加编译时间。使用@clss 还可以减少两个类之间的耦合。</p>
</blockquote>
<p><strong>3.应该将引入头文件的时机尽量延后（放在实现文件），只有确有需要的时候才引用，这样子可以减少类的使用者所需引用的头文件数量。缩短编译时间。</strong></p>
<ul>
<li><p>可以使用@class时，首选@class。</p>
</li>
<li><p>只有在迫不得已的时候才用#import (如：继承，实现协议)。</p>
</li>
<li><p>协议建议放在单独的一个头文件。避免引入协议时，引入头文件中等其他内容。</p>
</li>
<li><p>使用@class 可以减少.h中对其他类的依赖、减少链接到其他类所需要的时间，从而降低编译时间。</p>
</li>
</ul>
<p><strong>4. 两个类互相引用时： A类中引用B类，B类中也引用A类。必须用@class，不然会出现循环引用。</strong></p>
<h3 id="用-import-而不用-include"><a href="#用-import-而不用-include" class="headerlink" title="用#import 而不用 #include"></a>用#import 而不用 #include</h3><ul>
<li><p>import可以避免重复引用</p>
</li>
<li><p>如果用#include的话，需要进行避免重复的宏定义</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#ifndef HEADER</span><br><span class="line">#define HEADER</span><br><span class="line"></span><br><span class="line">xxx</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<h1 id="1-3-字面量语法、常量、枚举"><a href="#1-3-字面量语法、常量、枚举" class="headerlink" title="1.3-字面量语法、常量、枚举"></a>1.3-字面量语法、常量、枚举</h1><h2 id="一、尽量用字面量语法，便于理解"><a href="#一、尽量用字面量语法，便于理解" class="headerlink" title="一、尽量用字面量语法，便于理解"></a>一、尽量用字面量语法，便于理解</h2><p><strong>1. 字面数值</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 字面量语法</span><br><span class="line">NSNumber *itemNo = @1;</span><br><span class="line"></span><br><span class="line">// 传统声明</span><br><span class="line">NSNumber *itemNo = [NSNumber numberWithInt:1];</span><br></pre></td></tr></table></figure>
<p><strong>2. 字面量数组</strong></p>
<p>不能有nil值，nil值为结尾标示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSArray *arr1 = @[@&quot;1&quot;,@&quot;2&quot;];</span><br><span class="line"></span><br><span class="line">NSArray *arr2 = [NSArray arrayWithObjects:@&quot;1&quot;,@&quot;2&quot;,nil]; // 注意nil结尾</span><br></pre></td></tr></table></figure>
<p><strong>3. 字面量字典</strong></p>
<p>不能有nil值，nil值为结尾标示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSDictionary *dic = @&#123;@&quot;key1&quot;:@&quot;val1&quot;,</span><br><span class="line">                      @&quot;key2&quot;:@&quot;val2&quot;&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>4. 可变数组和字典</strong></p>
<p>字面创建的都是不可变类型，如果想创建可变类型，需要mutableCopy</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSMutableDictionary *dic = [@&#123;@&quot;key1&quot;:@&quot;val1&quot;,</span><br><span class="line">                              @&quot;key2&quot;:@&quot;val2&quot;&#125; mutableCopy];</span><br></pre></td></tr></table></figure>
<p><strong>5. 字符串字面量创建的是常量，对象不在持有了也不会立马被释放</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Oc会做字符串的编译单元，而且会合并相同字符串的编译单元，来减少额外的消耗去链接这些编译单元。</span><br><span class="line"></span><br><span class="line">NSString str1 = @“i am yun”;</span><br><span class="line">NSString str2 = @“i am yun”;</span><br><span class="line"></span><br><span class="line">// 此时，str1跟str2内存地址是一样的。</span><br><span class="line"></span><br><span class="line">// 字符串常量创建后，不再修改。即使引用它的对象不再指向它，字符串常量也不会立即施放。</span><br></pre></td></tr></table></figure>
<h2 id="二、-多用类型常量，少用预处理"><a href="#二、-多用类型常量，少用预处理" class="headerlink" title="二、 多用类型常量，少用预处理"></a>二、 多用类型常量，少用预处理</h2><p><strong>1. 不要用预处理命令定义常量，用静态常量代替</strong></p>
<p>预处理命令定义的，不含有类型信息</p>
<p><strong>2. 类内使用的常量，定义在实现文件，可用k做前缀</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// in the implementation file</span><br><span class="line">static const int kTimeItv = 1;</span><br></pre></td></tr></table></figure>
<p><strong>3. 如果需要其他类引用常量，在接口用extern定义，在实现文件实现，可用类名做前缀，如通知键值</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// in the interface</span><br><span class="line">extern const NSString *notiKey;</span><br><span class="line"></span><br><span class="line">// in the implementation file</span><br><span class="line">const  NSString *notiKey = @&quot;notiKey&quot;;</span><br></pre></td></tr></table></figure>
<p><strong>4. 编译器会在 “数据段”（data section）为字符串分配存储空间，这里在上面C 语言的内存模型有讲，数据段通常是指用来存放程序中已初始化的全局变量的一块内存区域。数据段属于静态内存分配。</strong></p>
<h2 id="三、-用枚举表示状态、选项、状态码"><a href="#三、-用枚举表示状态、选项、状态码" class="headerlink" title="三、 用枚举表示状态、选项、状态码"></a>三、 用枚举表示状态、选项、状态码</h2><p><strong>1. 用宏来定义枚举类型</strong></p>
<p>这些宏具备向后兼容（backward compatibility）能力，如果目标平台编译器支持新标准，那就使用新式语法，否则改用旧式语法。</p>
<ul>
<li>NS_ENUM宏 定义通用枚举</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, NSWritingDirection) &#123;</span><br><span class="line">    NSWritingDirectionNatural     = -1,  //值为-1    </span><br><span class="line">    NSWritingDirectionLeftToRight = 0,   //值为0</span><br><span class="line">    NSWritingDirectionRightToLeft = 1    //值为1       </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>NS_OPTIONS宏 定义位移枚举</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_OPTIONS(NSUInteger, UISwipeGestureRecognizerDirection) &#123;</span><br><span class="line">    UISwipeGestureRecognizerDirectionNone  = 0,       //值为0</span><br><span class="line">    UISwipeGestureRecognizerDirectionRight = 1 &lt;&lt; 0,  //值为2的0次方</span><br><span class="line">    UISwipeGestureRecognizerDirectionLeft  = 1 &lt;&lt; 1,  //值为2的1次方</span><br><span class="line">    UISwipeGestureRecognizerDirectionUp    = 1 &lt;&lt; 2,  //值为2的2次方</span><br><span class="line">    UISwipeGestureRecognizerDirectionDown  = 1 &lt;&lt; 3   //值为2的3次方</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>2. 在switch 语句中，最好不要有default 分支，这样子要做到处理所有样式，这样子在新家类型的时候，没有default 编译器会发出警告，让我们注意到。</strong></p>
<p><strong>3. 实现枚举所用的数据类型取决于编译器，不过其二进制位（bit）的个数必须能完全表示下枚举编号才行，一个字节含8个二进制位，所以至多能表示256（2^8^）个枚举变量。</strong></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Yun</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">18</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">5</span>
                    <span class="site-state-item-name">categories</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">15</span>
                    <span class="site-state-item-name">tags</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yun</span>

  

  
</div>




  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Gemini</a> v6.4.1</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.4.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.4.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.4.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.4.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.4.1"></script>



  



  










  





  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
