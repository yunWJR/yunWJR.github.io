<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.4.1" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.4.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.4.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.4.1">


  <link rel="mask-icon" href="/images/logo.svg?v=6.4.1" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.4.1',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="Yun&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Yun&#39;s Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Yun&#39;s Blog">






  <link rel="canonical" href="http://yoursite.com/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Yun's Blog</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Yun's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Home</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />Archives</a>
  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/30/iOS-kits/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yun's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/30/iOS-kits/" itemprop="url">
                  我的 iOS 框架简介
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-01-30 10:10:00 / Modified: 10:17:13" itemprop="dateCreated datePublished" datetime="2019-01-30T10:10:00+08:00">2019-01-30</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="我的-iOS-框架简介"><a href="#我的-iOS-框架简介" class="headerlink" title="我的 iOS 框架简介"></a>我的 iOS 框架简介</h1><p>在平时 iOS 开发中，自己积累了一些功能框架，现在年前，正好有时间，把各个框架的功能和使用说明写了一下。希望能帮助到有用的人。</p>
<p>如果在使用中有什么BUG，疑问或者建议，都可以联系我：email:<a href="mailto:wangjr@mail.tsinghua.edu.cn" target="_blank" rel="noopener">wangjr@mail.tsinghua.edu.cn</a> </p>
<h2 id="1、YunBaseApp"><a href="#1、YunBaseApp" class="headerlink" title="1、YunBaseApp"></a>1、YunBaseApp</h2><p><a href="https://github.com/yunWJR/YunBaseApp" target="_blank" rel="noopener">github</a></p>
<p>自己开发的 iOS 应用开发的基本框架，涉及 App 中等各种功能：UIViewController 的封装、主题管理、帐号管理、日志管理、、加载页、提示信息、错误封装等。</p>
<p>主要模块：</p>
<ul>
<li><p>Account （用户信息管理）</p>
</li>
<li><p>ActionListView （Action选择控件）</p>
</li>
<li><p>AlertView （提示控件）</p>
</li>
<li><p>Cache （缓存管理）</p>
</li>
<li><p>Error （Error管理）</p>
</li>
<li><p>HudView （HudView 基类）</p>
</li>
<li><p>Log （日志封装）</p>
</li>
<li><p>Rqt （网络请求封装）</p>
</li>
<li><p>Theme （主题管理）</p>
</li>
<li><p>View （UIView 和 UIViewController 的封装）</p>
</li>
<li><p>ViewCategory (UIView 和 UIViewController的扩展)</p>
</li>
</ul>
<h2 id="2、YunKits"><a href="#2、YunKits" class="headerlink" title="2、YunKits"></a>2、YunKits</h2><p><a href="https://github.com/yunWJR/YunKits" target="_blank" rel="noopener">github</a></p>
<p>iOS 基本库的一些封装扩展。主要包括：</p>
<ul>
<li><p>BaseView （对UIView、UIViewController、UITableView 的一些扩展）</p>
</li>
<li><p>Categories （分类扩展）</p>
</li>
<li><p>Factory （一些对象和控件的工厂方法）</p>
</li>
<li><p>Macro （一些常用宏。建议少用宏，尽量用静态变量或者实例变量。）</p>
</li>
<li><p>Tools （工具类）</p>
</li>
</ul>
<h2 id="3-YunImgView"><a href="#3-YunImgView" class="headerlink" title="3. YunImgView"></a>3. YunImgView</h2><p><a href="https://github.com/yunWJR/YunImgView" target="_blank" rel="noopener">github</a></p>
<p>封装的 iOS 图片列表控件，用 Objective-C 编写</p>
<p>该库主要包括两部分：1）YunImgView 图片列表库。2）YunSelectImgHelper 图片视频选择库。</p>
<h2 id="4-YunQiniuHelper"><a href="#4-YunQiniuHelper" class="headerlink" title="4. YunQiniuHelper"></a>4. YunQiniuHelper</h2><p><a href="https://github.com/yunWJR/YunQiniuHelper" target="_blank" rel="noopener">github</a></p>
<p>自己封装的 iOS 端的七牛上传工具，使用 Objective-C。</p>
<p>可以上传单个文件，多个文件，指定 key。</p>
<h2 id="5-YunWebView"><a href="#5-YunWebView" class="headerlink" title="5. YunWebView"></a>5. YunWebView</h2><p><a href="https://github.com/yunWJR/YunWebView" target="_blank" rel="noopener">github</a></p>
<p>使用Objective-C 实现的自定义 WebView，封装了 App 接口提供给 Web 前端使用，适用于 App 内嵌功能网页。</p>
<h2 id="6-YunImageBrowser"><a href="#6-YunImageBrowser" class="headerlink" title="6. YunImageBrowser"></a>6. YunImageBrowser</h2><p><a href="https://github.com/yunWJR/YunImageBrowser" target="_blank" rel="noopener">github</a></p>
<p>基于MWPhotoBrowser，进行修改的图片浏览控件</p>
<ul>
<li>修改依赖库，支持最新的 SDWebImage</li>
<li>修改样式，支持 iPhone X</li>
<li>修复一些 BUG</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/23/iOS-aspect-summary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yun's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/23/iOS-aspect-summary/" itemprop="url">
                  iOS 实现AOP编程(Objective-C)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-11-23 17:26:56 / Modified: 17:27:06" itemprop="dateCreated datePublished" datetime="2018-11-23T17:26:56+08:00">2018-11-23</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="iOS-实现AOP编程-Objective-C"><a href="#iOS-实现AOP编程-Objective-C" class="headerlink" title="iOS 实现AOP编程(Objective-C)"></a>iOS 实现AOP编程(Objective-C)</h1><h2 id="一、AOP与OOP"><a href="#一、AOP与OOP" class="headerlink" title="一、AOP与OOP"></a>一、AOP与OOP</h2><ul>
<li><strong>OOP（Object Oriented Programming，面向对象编程）</strong></li>
</ul>
<blockquote>
<p>OOP比较经典的程序设计思想，面向对象的特点是封装、多态和继承。面向对象设计时，每个对象职责不同，封装的功能也不同。这样就进行了解耦，增加了代码的重用性、灵活性和扩展性。</p>
</blockquote>
<blockquote>
<p>但这种方式也存在一个问题，比如，我们在两个类中，可能都需要在每个方法中进行日志记录（功能完全一样）。按OOP 方式，需要两个类的方法中都加入日志功能。这样就会有很多重复代码，当需要更改日志记录功能时，每个实现的类都需要更改。</p>
</blockquote>
<blockquote>
<p>一种解决方法：将日志功能写在一个独立的类中，然后再在这两个类中调用该类的日志记录功能。修改日志功能只需要修改单独的类即可。但是各个类与独立类有耦合，当有一个类需要增加或移除日志记录功能时，需要修改该类。另一种方法就是 AOP。</p>
</blockquote>
<ul>
<li><strong>AOP（Aspect Oriented Program，面向切面编程）</strong></li>
</ul>
<blockquote>
<p>AOP 思想是一种在不修改源代码的情况下给程序动态统一添加功能的一种技术。一般通过预编译方式和运行期动态代理实现程序功能的统一维护。</p>
</blockquote>
<blockquote>
<p>一般而言，我们管切入到指定类指定方法的代码片段称为切面，而切入到哪些类、哪些方法则叫切入点。</p>
</blockquote>
<blockquote>
<p>AOP 与 OOP 配合，可以很好的分离应用的业务逻辑与系统级服务。有了AOP，我们就可以把几个类共有的代码，抽取到一个切片中，等到需要时再切入对象中去，从而改变其原有的行为。</p>
</blockquote>
<h2 id="二、-iOS实现-AOP"><a href="#二、-iOS实现-AOP" class="headerlink" title="二、 iOS实现 AOP"></a>二、 iOS实现 AOP</h2><p>实现 AOP 需要语言支持对对象的动态扩展，正好 Objective-C的 Runtime 特性可以实现。现在有两种实现方式：</p>
<ul>
<li><strong>1. Method Swizzling</strong></li>
</ul>
<ul>
<li><strong>2. 消息转发</strong></li>
</ul>
<h3 id="1-Method-Swizzling-实现-AOP"><a href="#1-Method-Swizzling-实现-AOP" class="headerlink" title="1. Method Swizzling 实现 AOP"></a>1. Method Swizzling 实现 AOP</h3><p>在Objective-C中调用一个方法，其实是向一个对象发送消息，查找消息的唯一依据是selector的名字。</p>
<p>利用Objective-C的动态特性，可以实现在运行时偷换selector对应的方法实现。 </p>
<p>每个类都有一个方法列表，存放着selector的名字和方法实现的映射关系。IMP有点类似函数指针，指向具体的Method实现。 </p>
<ul>
<li>每个类（Class）维护一张调度表（dispatch table）用于解析运行时发送的消息；</li>
<li>调度表中的每个实体（entry）都是一个方法（Method），其中key值是一个唯一的名字——选择器（SEL），它对应到一个实现（IMP - 实际上就是指向标准C函数的指针）。</li>
</ul>
<p>Method Swizzling就是改变类中SEL 的具体实现函数IMP。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct objc_method &#123;</span><br><span class="line">    SEL method_name             OBJC2_UNAVAILABLE; // selector 名字</span><br><span class="line">    char *method_types          OBJC2_UNAVAILABLE;</span><br><span class="line">    IMP method_imp              OBJC2_UNAVAILABLE; // IMP 实现方法，运行时可更改</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">// 常用函数</span><br><span class="line">- method_exchangeImplementations  // 交换2个方法中的IMP</span><br><span class="line"></span><br><span class="line">- class_replaceMethod // 会调用class_addMethod和method_setImplementation，先实现方法，再设置IMP</span><br><span class="line"></span><br><span class="line">- method_setImplementation // 直接设置某个方法的IMP</span><br></pre></td></tr></table></figure>
<p>可参考<a href="https://yunwjr.github.io/2018/06/18/iOS-book-EffectiveObjective-C2.0-chap2/" target="_blank" rel="noopener">EffectiveObjective-C2.0 笔记 - 第二部分</a></p>
<p><strong>示例 - 日志打印</strong></p>
<ul>
<li><strong>封装的 Swizzling 方法</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">+ (void)swizzClass:(Class)classItem originSel:(SEL)originSel newSel:(SEL)newSel &#123;</span><br><span class="line">    Method orgMd = class_getInstanceMethod(classItem, originSel);</span><br><span class="line">    Method newMd = class_getInstanceMethod(classItem, newSel);</span><br><span class="line"></span><br><span class="line">    IMP newImp = method_getImplementation(newMd);</span><br><span class="line"></span><br><span class="line">    // 检查源方法有没有实现</span><br><span class="line">    // 如果是YES,表示originSel没有实现，则需要先实现，然后再设置Imp</span><br><span class="line">    // 如果是NO,表示originSel已经有存在的实现方法，此时，只需要将orgMd和newMd互换就好</span><br><span class="line">    BOOL isAddMdSuccess = class_addMethod(classItem, originSel, newImp, method_getTypeEncoding(newMd));</span><br><span class="line"></span><br><span class="line">    if (isAddMdSuccess) &#123;</span><br><span class="line">        // 会调用class_addMethod和method_setImplementation，先实现方法，再设置IMP</span><br><span class="line">        class_replaceMethod(classItem, originSel, newImp, method_getTypeEncoding(newMd));</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        // orgMd和newMd互换</span><br><span class="line">        method_exchangeImplementations(orgMd, newMd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>注意classItem，看你是替换类的方法，还是实例对象的放</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+ (Class)getClassItem &#123;</span><br><span class="line">    Class classItem = nil;</span><br><span class="line"></span><br><span class="line">    //要特别注意你替换的方法到底是哪个性质的方法</span><br><span class="line">    // When swizzling a Instance method, use the following:</span><br><span class="line">    // 仅替换本实例方法，子类方法不变</span><br><span class="line">    classItem = [self class];</span><br><span class="line"></span><br><span class="line">    // When swizzling a class method, use the following:</span><br><span class="line">    // 替换类方法</span><br><span class="line">    classItem = object_getClass((id) self);</span><br><span class="line"></span><br><span class="line">    return classItem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>在 load 中交换</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// load 中执行 Swizzling</span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line"></span><br><span class="line">    // dealloc是关键字，不能使用@selector(dealloc)</span><br><span class="line">    SEL orgSel = NSSelectorFromString(@&quot;dealloc&quot;);</span><br><span class="line"></span><br><span class="line">    SEL newSel = @selector(swizzing_dealloc);</span><br><span class="line"></span><br><span class="line">    // 保证仅执行一次</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        [self swizzClass:[self class]</span><br><span class="line">               originSel:orgSel</span><br><span class="line">                  newSel:newSel];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)swizzing_dealloc &#123;</span><br><span class="line">    NSLog(@&quot; ** %@ 释放了 %s&quot;, NSStringFromClass([self class]), __func__);</span><br><span class="line"></span><br><span class="line">    // 交换后，就不能用 [self dealloc]</span><br><span class="line">    [self swizzing_dealloc];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>为什么在 load 中交换</strong></li>
</ul>
<blockquote>
<p>+(void)load 方法只要类所在文件被引用就会被调用，在程序运行后立即执行（在main()之前执行），这样就可以在执行方法前，完成方法的替换。</p>
</blockquote>
<blockquote>
<p>另外 +(void)initialize 方是在类或者其子类的第一个方法被调用前调用，因为method swizzling会影响全局，+load能够保证在类初始化的时候就会被加载，这为改变系统行为提供了一些统一性。 但+initialize并不能保证在什么时候被调用——事实上也有可能永远也不会被调用，例如应用程序从未直接的给该类发送消息。</p>
</blockquote>
<p><strong>使用注意点：</strong></p>
<ol>
<li><p>Method Swizzling 需要在 + (void)load{}中使用</p>
</li>
<li><p>Method Swizzling 需要保证只执行一次。 需要使用 dispatch_once;</p>
</li>
<li><p>注意Class的选择，类对象还是实例对象</p>
</li>
<li><p>Method Swizzling 是以替换 IMP 来实现动态修改代码，这样实现的 AOP 不优雅，使用消息转发可以更优雅。</p>
</li>
</ol>
<h3 id="2-消息转发-实现-AOP"><a href="#2-消息转发-实现-AOP" class="headerlink" title="2. 消息转发 实现 AOP"></a>2. 消息转发 实现 AOP</h3><p><a href="https://github.com/steipete/Aspects" target="_blank" rel="noopener">Aspects</a>是一个已经实现的 AOP 轮子。下面结合Aspects对消息转发的实现进行分析。</p>
<h4 id="2-1-实例方法的执行"><a href="#2-1-实例方法的执行" class="headerlink" title="2.1 实例方法的执行"></a>2.1 实例方法的执行</h4><p>Objective-C 中执行实例方式，其实是给对象发送一个消息（<code>id objc_msgSend ( id self, SEL cmd, ... )</code>），执行流程如下：</p>
<p><img src="http://qnyunyun.yunsoho.cn/msg_send2.png" alt=""></p>
<ul>
<li>对象实例(instance)收到消息（selector 选择子+参数）</li>
<li>根据对象实例的ISA找到类对象，在类对象中找与选择子名称相符的方法，如果找到，就调至执行代码</li>
<li>如果找不到，则根据类对象中的super_class指针找到父类的Class对象。一直找到NSObject的类对象</li>
<li>如果NSObject也无法找到这个选择子，则进入消息转发机制（message forwarding）</li>
<li>如果消息转发机制无法处理，则抛出异常: <code>doesNotRecognizeSelector:</code></li>
</ul>
<h4 id="2-2-消息转发机制"><a href="#2-2-消息转发机制" class="headerlink" title="2.2 消息转发机制"></a>2.2 消息转发机制</h4><p>在Objective C的方法调用过程中，当无法响应一个selector时，在抛出异常之前会先进入消息转发机制。这里来详细讲解消息转发的过程：</p>
<p>关于消息转发，官方文档在这里： <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtForwarding.html#//apple_ref/doc/uid/TP40008048-CH105-SW2" target="_blank" rel="noopener">Message Forwarding</a></p>
<p>其他参考<a href="https://yunwjr.github.io/2018/06/18/iOS-book-EffectiveObjective-C2.0-chap2/" target="_blank" rel="noopener">二、 消息转发</a></p>
<p><img src="http://qnyunyun.yunsoho.cn/message%20forwarding.png" alt=""></p>
<p>在触发消息转发机制即<code>forwardInvocation:</code>之前，Runtime提供了两步来进行轻量级的动态处理这个selector.</p>
<ul>
<li><strong>1. 动态方法 <code>resolveInstanceMethod:</code></strong></li>
</ul>
<blockquote>
<p>Dynamically provides an implementation for a given selector for an instance method.</p>
</blockquote>
<p>这个方法提供了一个机会：为当前类无法识别的SEL动态增加IMP。</p>
<p>比如：可以通过<code>class_addMethod</code>增加 IMP</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void dynamicMethodIMP(id self, SEL _cmd) &#123;/*...implementation...*/&#125;</span><br><span class="line"></span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)aSEL &#123;</span><br><span class="line">    if (aSEL == @selector(resolveThisMethodDynamically)) &#123;</span><br><span class="line">        class_addMethod([self class], aSEL, (IMP) dynamicMethodIMP, &quot;v@:&quot;);</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return [super resolveInstanceMethod:aSel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// &quot;v@:&quot;表示方法参数编码，v表示Void，@表示OC对象，:表示SEL类型。</span><br></pre></td></tr></table></figure>
<p>如果<code>resolveInstanceMethod</code>返回NO，则表示无法在这一步动态的添加方法，则进入下一步：</p>
<ul>
<li><strong>2. 备援接收者 <code>forwardingTargetForSelector:</code></strong></li>
</ul>
<blockquote>
<p>Returns the object to which unrecognized messages should first be directed.</p>
</blockquote>
<p>这个方法提供了一个机会：把这个SEL转给其他接收者来处理。</p>
<p>比如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    if (aSelector == @selector(dynamicSelector) &amp;&amp;</span><br><span class="line">        [self.myObj respondsToSelector:@selector(dynamicSelector)]) &#123;</span><br><span class="line">        return self.myObj;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        return [super forwardingTargetForSelector:aSelector];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>3. 消息转发 message forwarding</strong></li>
</ul>
<p>如果上述两步都无法完成这个SEL的处理，则进入消息转发机制，消息转发机制有两个比较重要的方法：</p>
<ul>
<li>forwardInvocation: 具体的NSInvocaion</li>
<li>methodSignatureForSelector: 返回SEL的方法签名</li>
</ul>
<p>这里不得不提一下两个类：</p>
<ul>
<li>NSMethodSignature 用来表示方法的参数签名信息：返回值，参数数量和类型</li>
<li>NSInvocaion SEL + 执行SEL的Target + 参数值</li>
</ul>
<p>通常，拿到NSInvocaion对象后，我们可选择的进行如下操作</p>
<ul>
<li>修改执行的SEL</li>
<li>修改执行的Target</li>
<li>修改传入的参数</li>
</ul>
<p>然后调用：<code>[invocation invoke]</code>，来执行这个消息。</p>
<p><strong><code>_objc_msgForward</code></strong></p>
<p>我们知道，正常情况下SEL背后会对一个IMP，在OC中有一个特殊的IMP就是：<code>_objc_msgForward</code>。当执行<code>_objc_msgForward</code>时，会直接触发消息转发机制，即<code>forwardInvocation:</code>。</p>
<h4 id="2-3-Method-Swizzling"><a href="#2-3-Method-Swizzling" class="headerlink" title="2.3 Method Swizzling"></a>2.3 Method Swizzling</h4><p>上一节已经介绍了Method Swizzling，可以替换SEL 对应的IMP。</p>
<h4 id="2-4-Aspect-实现"><a href="#2-4-Aspect-实现" class="headerlink" title="2.4 Aspect 实现"></a>2.4 Aspect 实现</h4><p>使用Aspect，可以在一个OC方法执行前/后插入代码，也可以替换这个OC方法的实现。通过作者暴露的2个接口可以实现对实例和类的 Hook:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (id&lt;AspectToken&gt;)aspect_hookSelector:(SEL)selector</span><br><span class="line">                           withOptions:(AspectOptions)options</span><br><span class="line">                            usingBlock:(id)block</span><br><span class="line">                                 error:(NSError **)error;</span><br><span class="line"> </span><br><span class="line">- (id&lt;AspectToken&gt;)aspect_hookSelector:(SEL)selector</span><br><span class="line">                           withOptions:(AspectOptions)options</span><br><span class="line">                            usingBlock:(id)block</span><br><span class="line">                                 error:(NSError **)error;</span><br></pre></td></tr></table></figure>
<p>下面以在ViewControler的viewWillAppear:方法之后插入一段代码为例，来讲解hook前后的变化</p>
<p><strong>1) 在没有hook之前，ViewController的SEL与IMP关系如下</strong></p>
<p><img src="http://qnyunyun.yunsoho.cn/iOSAspect1.jpg?imageMogr2/thumbnail/!100p" alt=""></p>
<p><strong>2) 调用以下aspect来Hook viewWillAppear:后</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[ViewController aspect_hookSelector:@selector(viewWillAppear:)</span><br><span class="line">                            withOptions:AspectPositionAfter</span><br><span class="line">                             usingBlock:^&#123;</span><br><span class="line">                                 NSLog(@&quot;Insert some code after ViewWillAppear&quot;);</span><br><span class="line">                             &#125; error:&amp;error];</span><br></pre></td></tr></table></figure>
<p><img src="http://qnyunyun.yunsoho.cn/iOSAspect3.jpg?imageMogr2/thumbnail/!100p" alt=""></p>
<ul>
<li>最初的viewWillAppear: 指向了_objc_msgForward</li>
<li>增加了aspects_viewWillAppear:,指向最初的viewWillAppear:的IMP</li>
<li>最初的forwardInvocation:指向了Aspect提供的一个C方法<strong>ASPECTS_ARE_BEING_CALLED</strong></li>
<li>动态增加了aspects_forwardInvocation:,指向最初的forwardInvocation:的IMP</li>
</ul>
<p><strong>3) hook后，一个viewWillAppear:的实际调用顺序：</strong></p>
<ul>
<li>object收到selector(viewWillAppear:)的消息</li>
<li>找到对应的IMP：_objc_msgForward，执行后触发消息转发机制。</li>
<li>object收到forwardInvocation:消息</li>
<li>找到对应的IMP：<strong>ASPECTS_ARE_BEING_CALLED</strong>，执行IMP <ul>
<li>向object对象发送aspects_viewWillAppear:,执行最初的viewWillAppear方法的IMP</li>
<li>执行插入的block代码</li>
<li>如果ViewController无法响应aspects_viewWillAppear，则向object对象发送__aspects_forwardInvocation:来执行最初的forwardInvocation IMP</li>
</ul>
</li>
</ul>
<blockquote>
<p>所以，Aspects是采用了集中式的hook方式，所有的调用最后走的都是一个C函数<strong>ASPECTS_ARE_BEING_CALLED</strong>。</p>
</blockquote>
<h5 id="2-4-1-核心类-数据结构"><a href="#2-4-1-核心类-数据结构" class="headerlink" title="2.4.1 核心类/数据结构"></a>2.4.1 核心类/数据结构</h5><p><img src="http://qnyunyun.yunsoho.cn/iOSAspect5.jpg?imageMogr2/thumbnail/!100p" alt=""></p>
<p><strong>1） Aspects 内部定义了两个协议：</strong></p>
<ul>
<li><strong>AspectToken</strong> </li>
</ul>
<p>AspectToken 协议旨在让使用者可以灵活的注销之前添加过的 Hook</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/// 用于注销 Hook</span><br><span class="line">@protocol AspectToken /// 注销一个 aspect.</span><br><span class="line">/// 返回 YES 表示注销成功，否则返回 NO</span><br><span class="line">- (BOOL)remove;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>AspectInfo</strong> </li>
</ul>
<p>AspectInfo 协议旨在规范对一个切面，即 aspect 的 Hook 内部信息的纰漏，在 Hook 时添加切面的 Block 第一个参数就遵守此协议。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/// AspectInfo 协议是嵌入 Hook 的Block的第一个参数。</span><br><span class="line">@protocol AspectInfo /// 当前被 Hook 的实例</span><br><span class="line">- (id)instance;</span><br><span class="line">/// 被 Hook 方法的原始 invocation</span><br><span class="line">- (NSInvocation *)originalInvocation;</span><br><span class="line">/// 所有方法参数（装箱之后的）惰性执行</span><br><span class="line">- (NSArray *)arguments;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p><strong>2） Aspects 内部还定义了 4 个类：</strong></p>
<ul>
<li><strong>AspectInfo</strong> </li>
</ul>
<p>切面信息：NSInvocation的容器，表示一个执行的Command，遵循 AspectInfo 协议。AspectInfo 扮演了一个提供 Hook 信息的角色。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@interface AspectInfo : NSObject &lt;AspectInfo&gt;</span><br><span class="line">@property (nonatomic, unsafe_unretained, readonly) id instance;</span><br><span class="line">@property (nonatomic, strong, readonly) NSArray *arguments;</span><br><span class="line">@property (nonatomic, strong, readonly) NSInvocation *originalInvocation;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>AspectIdentifier</strong> </li>
</ul>
<p>切面 ID：代表一个Aspect的具体信息，包括被Hook的对象，SEL，插入的block等具体信息，遵循 AspectToken 协议。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@interface AspectIdentifier : NSObject</span><br><span class="line">@property (nonatomic, assign) SEL selector;</span><br><span class="line">@property (nonatomic, strong) id block;</span><br><span class="line">@property (nonatomic, strong) NSMethodSignature *blockSignature;</span><br><span class="line">@property (nonatomic, weak) id object;</span><br><span class="line">@property (nonatomic, assign) AspectOptions options;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>AspectContainer</strong> </li>
</ul>
<p>AspectIdentifier的容器：以SEL合成key，然后作为关联对象存储到对应的类/对象里。包括beforeAspects，insteadAspects，afterAspects</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@interface AspectsContainer : NSObject</span><br><span class="line">@property (atomic, copy) NSArray *beforeAspects;</span><br><span class="line">@property (atomic, copy) NSArray *insteadAspects;</span><br><span class="line">@property (atomic, copy) NSArray *afterAspects;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>AspectTracker</strong> </li>
</ul>
<p>切面跟踪器：跟踪一个类的继承链中的hook状态：包括被hook的类，哪些SEL被hook了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@interface AspectTracker : NSObject</span><br><span class="line">@property (nonatomic, strong) Class trackedClass;</span><br><span class="line">@property (nonatomic, readonly) NSString *trackedClassName;</span><br><span class="line">@property (nonatomic, strong) NSMutableSet *selectorNames;</span><br><span class="line">@property (nonatomic, strong) NSMutableDictionary *selectorNamesToSubclassTrackers;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>其原理大致为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// Add the selector as being modified.</span><br><span class="line">currentClass = klass;</span><br><span class="line">AspectTracker *parentTracker = nil;</span><br><span class="line">do &#123;</span><br><span class="line">    AspectTracker *tracker = swizzledClassesDict[currentClass];</span><br><span class="line">    if (!tracker) &#123;</span><br><span class="line">        tracker = [[AspectTracker alloc] initWithTrackedClass:currentClass parent:parentTracker];</span><br><span class="line">        swizzledClassesDict[(id)currentClass] = tracker;</span><br><span class="line">    &#125;</span><br><span class="line">    [tracker.selectorNames addObject:selectorName];</span><br><span class="line">    // All superclasses get marked as having a subclass that is modified.</span><br><span class="line">    parentTracker = tracker;</span><br><span class="line">&#125;while ((currentClass = class_getSuperclass(currentClass)));</span><br></pre></td></tr></table></figure>
<blockquote>
<p>AspectTracker 是从下而上追踪，最底层的 parentEntry 为 nil，父类的 parentEntry 为子类的 tracker。</p>
</blockquote>
<p><strong>3）一个结构体：</strong></p>
<ul>
<li>AspectBlockRef - 即 _AspectBlock，充当内部 Block</li>
</ul>
<p><strong>4）两个内部静态全局变量：</strong></p>
<ul>
<li>static NSMutableDictionary *swizzledClassesDict;</li>
<li>static NSMutableSet *swizzledClasses;</li>
</ul>
<h5 id="2-4-2-hook过程"><a href="#2-4-2-hook过程" class="headerlink" title="2.4.2 hook过程"></a>2.4.2 hook过程</h5><p><strong>1. 对Class和MetaClass进行进行合法性检查，判断能否hook，规则如下</strong></p>
<ul>
<li>retain,release,autorelease,forwoardInvocation:不能被hook</li>
<li>dealloc只能在方法前hook</li>
<li>类的继承关系中，同一个方法只能被hook一次</li>
</ul>
<p><strong>2. 创建AspectsContainer对象，以aspects_ + SEL为key，作为关联对象依附到被hook 的对象上</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_setAssociatedObject(self, aliasSelector, aspectContainer, OBJC_ASSOCIATION_RETAIN);</span><br></pre></td></tr></table></figure>
<p><strong>3. 创建AspectIdentifier对象，并且添加到AspectsContainer对象里存储起来。这个过程分为两步</strong> </p>
<ul>
<li>生成block的方法签名NSMethodSignature</li>
<li>对比block的方法签名和待hook的方法签名是否兼容（参数个数，按照顺序的类型）</li>
</ul>
<p><strong>4. 根据hook实例对象/类对象／类元对象的方法做不同处理。其中，对于上文以类方法来hook的时候，分为两步</strong></p>
<ul>
<li>hook类对象的forwoardInvocation:方法，指向一个静态的C方法，并且创建一个aspects_ forwoardInvocation:动态添加到之前的类中</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IMP originalImplementation = class_replaceMethod(klass, @selector(forwardInvocation:), (IMP)__ASPECTS_ARE_BEING_CALLED__, &quot;v@:@&quot;);</span><br><span class="line">if (originalImplementation) &#123;</span><br><span class="line">    class_addMethod(klass, NSSelectorFromString(AspectsForwardInvocationSelectorName), originalImplementation, &quot;v@:@&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>hook类对象的viewWillAppear:方法让其指向_objc_msgForward,动态添加aspects_viewWillAppear:指向最初的viewWillAppear:实现</li>
</ul>
<h5 id="2-4-3-Hook实例的方法"><a href="#2-4-3-Hook实例的方法" class="headerlink" title="2.4.3 Hook实例的方法"></a>2.4.3 Hook实例的方法</h5><blockquote>
<p>Aspects支持只hook一个对象的实例方法</p>
</blockquote>
<p>只不过在第4步略有出入，当hook一个对象的实例方法的时候：</p>
<ul>
<li>新建一个子类，_Aspects_ViewController,并且按照上述的方式hook forwoardInvocation:</li>
<li>hook _Aspects_ViewController的class方法，让其返回ViewController</li>
<li>hook 子类的类元对象，让其返回ViewController</li>
<li>调用objc_setClass来修改ViewController的类为_Aspects_ViewController</li>
</ul>
<blockquote>
<p>这样做，就可以通过object_getClass(self)获得类名，然后看看是否有前缀类名来判断是否被hook过了</p>
</blockquote>
<h5 id="2-4-4-其他"><a href="#2-4-4-其他" class="headerlink" title="2.4.4 其他"></a>2.4.4 其他</h5><p><strong>1) object_getClass/与self.class的区别</strong></p>
<ul>
<li>object_getClass获得的是isa的指向</li>
<li>self.class则不一样，当self是实例对象的时候，返回的是类对象，否则则返回自身。</li>
</ul>
<p>比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TestClass * testObj = [[TestClass alloc] init];</span><br><span class="line">//Same</span><br><span class="line">logAddress([testObj class]);</span><br><span class="line">logAddress([TestClass class]);</span><br><span class="line"></span><br><span class="line">//Not same</span><br><span class="line">logAddress(object_getClass(testObj));</span><br><span class="line">logAddress(object_getClass([TestClass class]));</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2017-05-22 22:41:48.216 OCTest[899:25934] 0x107d10930</span><br><span class="line">2017-05-22 22:41:48.216 OCTest[899:25934] 0x107d10930</span><br><span class="line">2017-05-22 22:41:48.216 OCTest[899:25934] 0x107d10930</span><br><span class="line">2017-05-22 22:41:49.061 OCTest[899:25934] 0x107d10908</span><br></pre></td></tr></table></figure>
<p><strong>2) Block签名</strong></p>
<p>block因为背后其实是一个C结构体，结构体中存储着着一个函数指针来指向实际的方法体</p>
<p>Block的内存布局如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_OPTIONS(int, AspectBlockFlags) &#123;</span><br><span class="line">    AspectBlockFlagsHasCopyDisposeHelpers = (1 &lt;&lt; 25),</span><br><span class="line">    AspectBlockFlagsHasSignature          = (1 &lt;&lt; 30)</span><br><span class="line">&#125;;</span><br><span class="line">typedef struct _AspectBlock &#123;</span><br><span class="line">    __unused Class isa;</span><br><span class="line">    AspectBlockFlags flags;</span><br><span class="line">    __unused int reserved;</span><br><span class="line">    void (__unused *invoke)(struct _AspectBlock *block, ...);</span><br><span class="line">    struct &#123;</span><br><span class="line">        unsigned long int reserved;</span><br><span class="line">        unsigned long int size;</span><br><span class="line">        // requires AspectBlockFlagsHasCopyDisposeHelpers</span><br><span class="line">        void (*copy)(void *dst, const void *src);</span><br><span class="line">        void (*dispose)(const void *);</span><br><span class="line">        // requires AspectBlockFlagsHasSignature</span><br><span class="line">        const char *signature;</span><br><span class="line">        const char *layout;</span><br><span class="line">    &#125; *descriptor;</span><br><span class="line">    // imported variables</span><br><span class="line">&#125; *AspectBlockRef;</span><br></pre></td></tr></table></figure>
<p>对应生成NSMethodSignature的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static NSMethodSignature *aspect_blockMethodSignature(id block, NSError **error) &#123;</span><br><span class="line">    AspectBlockRef layout = (__bridge void *)block;</span><br><span class="line">    if (!(layout-&gt;flags &amp; AspectBlockFlagsHasSignature)) &#123;</span><br><span class="line">        NSString *description = [NSString stringWithFormat:@&quot;The block %@ doesn&apos;t contain a type signature.&quot;, block];</span><br><span class="line">        AspectError(AspectErrorMissingBlockSignature, description);</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    void *desc = layout-&gt;descriptor;</span><br><span class="line">    desc += 2 * sizeof(unsigned long int);</span><br><span class="line">    if (layout-&gt;flags &amp; AspectBlockFlagsHasCopyDisposeHelpers) &#123;</span><br><span class="line">        desc += 2 * sizeof(void *);</span><br><span class="line">    &#125;</span><br><span class="line">    if (!desc) &#123;</span><br><span class="line">        NSString *description = [NSString stringWithFormat:@&quot;The block %@ doesn&apos;t has a type signature.&quot;, block];</span><br><span class="line">        AspectError(AspectErrorMissingBlockSignature, description);</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    const char *signature = (*(const char **)desc);</span><br><span class="line">    return [NSMethodSignature signatureWithObjCTypes:signature];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3) 效率</strong></p>
<blockquote>
<p>消息转发机制相对于正常的方法调用来说是比较昂贵的，所以一定不要用消息转发机制来处理那些一秒钟成百上千次的调用。</p>
</blockquote>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/03/iOS-adjust-iOS12/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yun's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/03/iOS-adjust-iOS12/" itemprop="url">
                  iOS12 XCode10 适配
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-11-03 17:22:31" itemprop="dateCreated datePublished" datetime="2018-11-03T17:22:31+08:00">2018-11-03</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2018-11-23 17:24:09" itemprop="dateModified" datetime="2018-11-23T17:24:09+08:00">2018-11-23</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="iOS12-XCode10-适配"><a href="#iOS12-XCode10-适配" class="headerlink" title="iOS12 XCode10 适配"></a>iOS12 XCode10 适配</h1><h2 id="1-libstdc-弃用-报错Undefined-symbols"><a href="#1-libstdc-弃用-报错Undefined-symbols" class="headerlink" title="1. libstdc++弃用  报错Undefined symbols"></a>1. libstdc++弃用  报错Undefined symbols</h2><p> XCode10编译报错<code>ndefined symbols for architecture XXX</code>，如果你的工程中有libstdc++依赖（可从Linked Frameworks and Libraries 项查看），那么就会出现这类错误。</p>
<p>因为苹果在XCode10和iOS12中移除了libstdc++这个库，由libc++这个库取而代之，苹果的解释是libstdc++已经标记为废弃有5年了，建议大家使用经过了llvm优化过并且全面支持C++11的libc++库。</p>
<blockquote>
<p>libstdc++.dylib是C++98版本的标准库实现动态库，而libc++.dylib是C++11版本的标准库实现动态库。libc++是一个更加新的C++标准库实现，它完全支持C++11标准。因此苹果弃用了libstdc++.dylib，这符合苹果一贯的作风。</p>
</blockquote>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><ul>
<li><p><strong>最直接的是修改依赖库，支持libc++.dylib</strong></p>
</li>
<li><p><strong>临时方法</strong></p>
<p>  将libstdc++.dylib拷贝到 XCode中，共四个地方</p>
<p>  <a href="http://qnyuntmp.yunsoho.cn/libstdc++.zip" target="_blank" rel="noopener">libstdc++.dylib下载地址</a></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo cp CoreSimulator/* /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/CoreSimulator/Profiles/Runtimes/iOS.simruntime/Contents/Resources/RuntimeRoot/usr/lib/</span><br><span class="line">sudo cp MacOSX/* /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/lib/</span><br><span class="line">sudo cp iPhoneOS/* /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/usr/lib/</span><br><span class="line">sudo cp iPhoneSimulator/* /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/lib/</span><br></pre></td></tr></table></figure>
<h2 id="2-UICollectionViewCell-高度计算不正确"><a href="#2-UICollectionViewCell-高度计算不正确" class="headerlink" title="2. UICollectionViewCell 高度计算不正确"></a>2. UICollectionViewCell 高度计算不正确</h2><p><strong>更新 iOS12后，一定要检查所有用到UICollectionViewCell的界面，因为UICollectionViewCell可能出现高度计算不正确的现象。</strong></p>
<p>iOS12对AutoLayout做出了性能优化，但是更新 iOS12后，发现一些UICollectionViewCell的高度不正确，一时间也调试不出什么问题，因此就采用手动计算高度暂时解决。</p>
<p>这里有一篇同样的问题，解决思路可供参考<a href="http://www.cocoachina.com/ios/20181023/25267.html" target="_blank" rel="noopener">链接</a></p>
<h3 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h3><ul>
<li><p><strong>1. 手动计算高度</strong></p>
</li>
<li><p><strong>2. 忽略 contentView，直接把 subView 加到 cell 上</strong></p>
</li>
</ul>
<h2 id="3-StatusBar-网络状态"><a href="#3-StatusBar-网络状态" class="headerlink" title="3. StatusBar 网络状态"></a>3. StatusBar 网络状态</h2><p>如果app通过状态栏的网络状态指示器去判断手机当前联网状态，修改进行修改，因为iOS12 更改了StatusBar内部结构。</p>
<p><a href="https://blog.csdn.net/wxs0124/article/details/80613847" target="_blank" rel="noopener">参考链接</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">+ (NSString *)getIphoneXNetWorkStates &#123;    </span><br><span class="line">    UIApplication *app = [UIApplication sharedApplication];</span><br><span class="line">    id statusBar = [[app valueForKeyPath:@&quot;statusBar&quot;] valueForKeyPath:@&quot;statusBar&quot;];</span><br><span class="line">    id one = [statusBar valueForKeyPath:@&quot;regions&quot;];</span><br><span class="line">    id two = [one valueForKeyPath:@&quot;trailing&quot;];</span><br><span class="line">    NSArray *three = [two valueForKeyPath:@&quot;displayItems&quot;];</span><br><span class="line">    NSString *state = @&quot;无网络&quot;;</span><br><span class="line">    for (UIView *view in three) &#123;</span><br><span class="line">        //alert: iOS12.0 情况下identifier的变成了类&quot;_UIStatusBarIdentifier&quot;而不是NSString，所以会在调用“isEqualToString”方法时发生crash，</span><br><span class="line">        //修改前</span><br><span class="line">//        NSString *identifier = [view valueForKeyPath:@&quot;identifier&quot;];</span><br><span class="line">        //修改后</span><br><span class="line">        NSString *identifier = [[view valueForKeyPath:@&quot;identifier&quot;] description];</span><br><span class="line">        if ([identifier isEqualToString:@&quot;_UIStatusBarWifiItem.signalStrengthDisplayIdentifier&quot;]) &#123;</span><br><span class="line">            id item = [view valueForKeyPath:@&quot;_item&quot;];</span><br><span class="line"></span><br><span class="line">            //alert: 这个问题和上边一样itemId是_UIStatusBarIdentifier 类型，不是string</span><br><span class="line">            NSString *itemId = [[item valueForKeyPath:@&quot;identifier&quot;] description];</span><br><span class="line">            if ([itemId isEqualToString:@&quot;_UIStatusBarWifiItem&quot;]) &#123;</span><br><span class="line">                state = @&quot;WIFI&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            state = @&quot;不确定&quot;;</span><br><span class="line"></span><br><span class="line">        &#125; else if ([identifier isEqualToString:@&quot;_UIStatusBarCellularItem.typeDisplayIdentifier&quot;]) &#123;</span><br><span class="line">            UIView *statusBarStringView = [view valueForKeyPath:@&quot;_view&quot;];</span><br><span class="line">            // 4G/3G/E</span><br><span class="line">            state = [statusBarStringView valueForKeyPath:@&quot;text&quot;];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="iOS12新功能"><a href="#iOS12新功能" class="headerlink" title="iOS12新功能"></a>iOS12新功能</h2><h3 id="1-刘海屏判断"><a href="#1-刘海屏判断" class="headerlink" title="1. 刘海屏判断"></a>1. 刘海屏判断</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define isNotchMobile ([UIScreen instancesRespondToSelector:@selector(currentMode)] ? (CGSizeEqualToSize(CGSizeMake(1125, 2436), [[UIScreen mainScreen] currentMode].size)||CGSizeEqualToSize(CGSizeMake(1242, 2688), [[UIScreen mainScreen] currentMode].size)||CGSizeEqualToSize(CGSizeMake(828, 1792), [[UIScreen mainScreen] currentMode].size)) : NO)</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/12/iOS-book-EffectiveObjective-C2.0-chap7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yun's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/12/iOS-book-EffectiveObjective-C2.0-chap7/" itemprop="url">
                  EffectiveObjective-C2.0 笔记 - 第七部分
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-10-12 21:43:22" itemprop="dateCreated datePublished" datetime="2018-10-12T21:43:22+08:00">2018-10-12</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2018-11-05 10:03:49" itemprop="dateModified" datetime="2018-11-05T10:03:49+08:00">2018-11-05</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>EffectiveObjective-C2.0 笔记 - 第七部分</strong></p>
<h1 id="7-系统框架"><a href="#7-系统框架" class="headerlink" title="7. 系统框架"></a>7. 系统框架</h1><h2 id="7-1-熟悉系统框架"><a href="#7-1-熟悉系统框架" class="headerlink" title="7.1 熟悉系统框架"></a>7.1 熟悉系统框架</h2><p><strong>1. 框架：将一系列代码封装成动态库，并在其中放入描述其接口的头文件。</strong></p>
<blockquote>
<p>平时我们第三方框架用的是静态库，因为iOS 应用程序不允许其中包含动态库。</p>
</blockquote>
<p><strong>2. Foundation、CoreFoundation 框架平时用的比较多，“无缝桥接” 可以将这两种框架的对象平滑转换。</strong></p>
<p><strong>3. 常用框架：</strong></p>
<ul>
<li>CFNetwork</li>
<li>CoreAudio</li>
<li>AVFoundation</li>
<li>CoreData</li>
<li>CoreText</li>
</ul>
<h2 id="7-2-多用块枚举，少用for-循环"><a href="#7-2-多用块枚举，少用for-循环" class="headerlink" title="7.2 多用块枚举，少用for 循环"></a>7.2 多用块枚举，少用for 循环</h2><p><strong>遍历collection 有四种方式。最基本的办法就是for 循环，其次是NSEnumerator 遍历法及快速遍历法，最新、最先进的方式则是 “块枚举法”。</strong></p>
<p><strong>1. for 循环</strong></p>
<p>简单粗暴，遍历数组还可以，但是对于遍历字典或者set，就不太友好。  </p>
<p><strong>2. 使用Objective-C 1.0 的NSEnumerator 来遍历</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NSArray *array = @[@&quot;A&quot;,@&quot;B&quot;,@&quot;C&quot;];</span><br><span class="line">NSEnumerator *enumerator = [array objectEnumerator];</span><br><span class="line">NSString *string;</span><br><span class="line">while ((string = [enumerator nextObject]) != nil) &#123;</span><br><span class="line">	NSLog(@&quot;%@&quot;,string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种遍历使用相对比较统一，数组、字典和set 都可以这样子写，并且还有多种 “枚举器” 可供使用，例如反向遍历数组的枚举器。</p>
<p><strong>3. 快速遍历</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (&lt;#type *object#&gt; in &lt;#collection#&gt;) &#123;</span><br><span class="line">    &lt;#statements#&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>for in  这个更加简洁，如果某个类的对象支持快速遍历，那么就可以宣称自己遵从名为NSFastEnumeration 的协议，从而令开发者可以采用此语法来迭代改对象。此协议只定义了一个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (NSUInteger)countByEnumeratingWithState:(NSFastEnumerationState *)state objects:(id __unsafe_unretained _Nullable [_Nonnull])buffer count:(NSUInteger)len;</span><br></pre></td></tr></table></figure>
<p>由于NSEnumerator 对象也实现了NSFastEnumeration 协议，所以能用来执行快速遍历。但是快速遍历拿不到当前操作对象的下标。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSArray *array = @[@&quot;A&quot;,@&quot;B&quot;,@&quot;C&quot;];</span><br><span class="line">for (NSString *string in [array reverseObjectEnumerator]) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4. 基于块的遍历方式</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NSArray *array = @[@&quot;A&quot;,@&quot;B&quot;,@&quot;C&quot;];</span><br><span class="line">[array enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[array enumerateObjectsWithOptions:NSEnumerationReverse usingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>“块枚举法” 本身就能通过GCD来并发执行遍历操作，无须另行编写代码。而采用其他遍历则无法轻易实现这一点。</p>
<p>此方式对于其他相比，在遍历时候可以直接在块中获取更多信息，而且这种对于字典的遍历也是非常友好的，一次性可以返回键和值。并且还可以支持反向遍历。</p>
<h2 id="7-3-对自定义其内存管理语义的collection使用无缝桥接"><a href="#7-3-对自定义其内存管理语义的collection使用无缝桥接" class="headerlink" title="7.3 对自定义其内存管理语义的collection使用无缝桥接"></a>7.3 对自定义其内存管理语义的collection使用无缝桥接</h2><p><strong>无缝桥接</strong></p>
<p>使用 “无缝桥接” 计数，可以在定义于Foundation框架中的Objective-C类和定义于CoreFoundation框架中的C数据结构之间相互转换。</p>
<p><strong>1. 三种转换方式</strong></p>
<ul>
<li>__bridge 只是声明类型转变，但是不做内存管理规则的转变</li>
<li>__bridge_retained 表示将指针类型转变的同时，将内存管理的责任由原来的Objective-C 交给Core Foundation 来处理，也就是ARC 转变成 MRC</li>
<li>__bridge_transfer 表示将管理的责任由Core Foundation 转交给Objective-C，即将MRC转变成ARC</li>
</ul>
<ol>
<li>Foundation中字典对象无缝桥接：</li>
</ol>
<blockquote>
<p>Foundation中字典对象，对其键的内存管理语义为 “拷贝”，而值的语义是 “保留”。只能通过强大的无缝桥接技术，否则无法改变其语义。</p>
</blockquote>
<p>   CoreFoundation 框架的字典类型是CFDictionary，可变版本是CFMutableDictionary。</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">//CFMutableDictionary 用CFDictionaryCreateMutable 来创建</span><br><span class="line">//用CFDictionaryCreateMutable 定义</span><br><span class="line">CFMutableDictionaryRef CFDictionaryCreateMutable (</span><br><span class="line">  CFAllocatorRef allocator, </span><br><span class="line">  CFIndex capacity, </span><br><span class="line">  const CFDictionaryKeyCallBacks *keyCallBacks, </span><br><span class="line">  const CFDictionaryValueCallBacks *valueCallBacks</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">/*CFAllocatorRef 表示将要使用的内存分配器，CoreFoundation 对象里的数据结构需要占用内存，而分配器负责分配及回收这些内存，一般传NULL，表示采用默认的分配器。</span><br><span class="line"></span><br><span class="line">CFIndex 表示字典的初始大小，跟我们Foundation 字典的创建一样，并不限制最大容量 就是预先分配内存</span><br><span class="line"></span><br><span class="line">最后两个参数都是指向结构体的指针，定义了很多回调函数，用于指示字典中的键和值遇到各种事件时应该执行何种操作。</span><br><span class="line"></span><br><span class="line">CFDictionaryKeyCallBacks 的结构体定义</span><br><span class="line">typedef struct &#123;</span><br><span class="line">    CFIndex				version;</span><br><span class="line">    CFDictionaryRetainCallBack		retain;</span><br><span class="line">    CFDictionaryReleaseCallBack		release;</span><br><span class="line">    CFDictionaryCopyDescriptionCallBack	copyDescription;</span><br><span class="line">    CFDictionaryEqualCallBack		equal;</span><br><span class="line">    CFDictionaryHashCallBack		hash;</span><br><span class="line">&#125; CFDictionaryKeyCallBacks;</span><br><span class="line"></span><br><span class="line">CFDictionaryValueCallBacks 的结构体定义</span><br><span class="line">typedef struct &#123;</span><br><span class="line">    CFIndex				version;</span><br><span class="line">    CFDictionaryRetainCallBack		retain;</span><br><span class="line">    CFDictionaryReleaseCallBack		release;</span><br><span class="line">    CFDictionaryCopyDescriptionCallBack	copyDescription;</span><br><span class="line">    CFDictionaryEqualCallBack		equal;</span><br><span class="line">&#125; CFDictionaryValueCallBacks;</span><br><span class="line"></span><br><span class="line">version 参数目前应设置为0，表示版本号；</span><br><span class="line">其他参数都是函数指针，例如，字典加入了新的键与值，那么就会调用retain 函数，定义如下：</span><br><span class="line">typedef const void *(*CFDictionaryRetainCallBack)(</span><br><span class="line">	CFAllocatorRef allocator, </span><br><span class="line">	const void *value</span><br><span class="line">);</span><br><span class="line">retain 是个函数指针，其所指向的函数接受两个参数，其类型分别是CFAllocatorRef、const void *。传给此函数的value 参数表示即将加入字典中的键或值。而返回的void * 则表示加到字典里的最终值。我们可以这样子实现：</span><br><span class="line">const void *CustomCallback（CFAllocatorRef allocator，const void *value）&#123;</span><br><span class="line">	return value;</span><br><span class="line">&#125;</span><br><span class="line">如果用它充当retain 回调函数来创建字典，那么该字典就不会 “保留” 键和值。然后再利用无缝桥接搭配起来，就可以创建特殊的NSDictionary 对象，跟我们普通的字典不一样。</span><br><span class="line"></span><br><span class="line">开发者可以直接在CoreFoundation 层创建字典，于是就能修改内存管理语义，对键执行 “保留” 而非 “拷贝” 操作了。</span><br></pre></td></tr></table></figure>
<h2 id="7-4-构建缓存时选用NSCache而非-NSDictionay"><a href="#7-4-构建缓存时选用NSCache而非-NSDictionay" class="headerlink" title="7.4 构建缓存时选用NSCache而非 NSDictionay"></a>7.4 构建缓存时选用NSCache而非 NSDictionay</h2><p><strong>1. 实现缓存时应选用NSCache而非NSDictionary 对象。</strong></p>
<blockquote>
<p>NSCache 是专门来处理缓存的，在系统资源将要耗尽时，它可以自动删减缓存。而且是线程安全的，此外，它与字典不同，并不会拷贝健。</p>
</blockquote>
<p><strong>2. 可以给NSCache 对象设置上限</strong></p>
<blockquote>
<p>可以给NSCache 对象设置上限，用以限制缓存中的对象总个数及总成本，而这些尺度则定义了缓存删减其中对象的时机。但是绝对不要把这些尺度当成可靠的 “硬限制”，它们仅对NSCache其指导作用。</p>
</blockquote>
<p><strong>3. NSPurgeableData 与 NSCache 搭配使用</strong></p>
<blockquote>
<p> NSPurgeableData类是NSMutableData的子类，而且实现了NSDiscardableContent协议。将NSPurgeableData 与 NSCache 搭配使用，可实现自动清除数据的功能，也就是说，当NSPurgeableData 对象所占内存为系统丢弃时，该对象也会从缓存中移除。</p>
</blockquote>
<p><strong>4. 如果缓存使用得当，那么应用程序的响应速度就能提高。</strong></p>
<blockquote>
<p>只有那种 “重新计算起来很费事的” 数据，才值得放入缓存，比如那些需要从网络获取或从磁盘读取的数据。</p>
</blockquote>
<h2 id="7-5-精简initalize与load的实现代码"><a href="#7-5-精简initalize与load的实现代码" class="headerlink" title="7.5 精简initalize与load的实现代码"></a>7.5 精简initalize与load的实现代码</h2><p><strong>1. 在加载阶段，如果类实现了load 方法，那么系统就会调用它。分类里也可以定义此方法，类的load 方法要比分类中的先调用。与其他方法不同，load 方法不参与覆写机制。</strong></p>
<ul>
<li><p>对于加入运行期系统中的每个类及分类，必定会调用load这个方法，而且仅调用一次。意思就是程序启动的时候需要加载load方法，这个时候运行期系统也是出于 “脆弱状态”，在执行子类的load方法之前，必定会先执行所有超类的load 方法。</p>
</li>
<li><p>如果load 代码还依赖了其他类，那类的load 也必然会先执行，我们无法判断每个类的载入顺序，所以load 方法使用其他类是不安全的。</p>
</li>
<li><p>load 方法不遵从继承规则，如果某个类没实现load 方法，那么不管其各级超类是否实现此方法，系统都不会调用。</p>
</li>
<li><p>load 方法要实现的精简点，因为应用程序在执行load 方法会阻塞。load 一般作为调试用，很少用来做初始化操作。</p>
</li>
</ul>
<p><strong>2. load 与initialize 方法都应该实现得精简一些，这有助于保持应用程序的响应能力，也能减少引入 “依赖环” 的几率。</strong></p>
<ul>
<li><p>想执行与类相关的初始化操作，可以使用 <code>+(void)initialize</code>  这个方法，它跟load 有以下几个区别：</p>
<ul>
<li>这个方法是在首次使用这个类的时候调用，类似 “惰性调用” ，只有用到这个类才会调用。</li>
</ul>
</li>
</ul>
<ul>
<li>运行期在执行该方法的时候，是出于正常状态的，此时是可以安全调用任意类的任意方法，而且运行期系统会确保initialize 方法一定在 “线程安全的环境” 中执行。其他线程都要先阻塞，等initialize 执行完。</li>
<li>initialize 方法跟其他方法一样，某个类没有实现它，而超类方法实现了，那么就会运行超类的实现代码。</li>
</ul>
<ul>
<li><p>也就是说initalize 与 load 的实现代码要精简些。</p>
</li>
<li><p>若某个全局状态无法在编译期初始化，则可以放在initalize 里来做。（例如Objectice-C 对象，创建实例之前必须先激活运行期系统）</p>
</li>
</ul>
<h2 id="7-6-别忘了NSTimer会保留其目标对象"><a href="#7-6-别忘了NSTimer会保留其目标对象" class="headerlink" title="7.6 别忘了NSTimer会保留其目标对象"></a>7.6 别忘了NSTimer会保留其目标对象</h2><p><strong>1. 计时器放在运行循环里，它才能正常触发任务。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ scheduledTimerWithTimeInterval:target:selector:userInfo:repeats:</span><br></pre></td></tr></table></figure>
<p><strong>2. 计时器保留环</strong></p>
<p>   计时器会保留其目标对象，等到自身 “失效” 时再释放此对象，调用invalidate 方法可令计时器失效，另外，一次性的计时器在触发完任务之后也会失效。设置成重复执行模式的计时器，要注意 “保留环” 问题。</p>
<p><strong>3. 如何解决外界不调用invalidate方法也不产生 “保留环” 的问题</strong>。</p>
<p>   可以用块来解决这个问题，其实就是将timer的target 对象不要指向持有timer的对象，这里用的方法是让timer 的taerget 指向自己。</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//定义</span><br><span class="line">+ (NSTimer *)my_scheduledTimerWithTimeInterval:(NSTimeInterval)ti</span><br><span class="line">                                         block:(void(^)())block</span><br><span class="line">                                       repeats:(BOOL)yesOrNo;</span><br><span class="line"></span><br><span class="line">//实现</span><br><span class="line">+ (NSTimer *)my_scheduledTimerWithTimeInterval:(NSTimeInterval)ti</span><br><span class="line">                                         block:(void(^)())block</span><br><span class="line">                                       repeats:(BOOL)yesOrNo &#123;</span><br><span class="line">    return [self scheduledTimerWithTimeInterval:ti</span><br><span class="line">                                         target:self</span><br><span class="line">                                       selector:@selector(my_blockInvoke:)</span><br><span class="line">                                       userInfo:[block copy]</span><br><span class="line">                                        repeats:yesOrNo];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)my_blockInvoke:(NSTimer *)timer &#123;</span><br><span class="line">    void (^block) () = timer.userInfo;</span><br><span class="line">    if (block) &#123;</span><br><span class="line">        block();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/07/iOS-book-EffectiveObjective-C2.0-chap6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yun's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/07/iOS-book-EffectiveObjective-C2.0-chap6/" itemprop="url">
                  EffectiveObjective-C2.0 笔记 - 第六部分
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-10-07 21:11:45" itemprop="dateCreated datePublished" datetime="2018-10-07T21:11:45+08:00">2018-10-07</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-01-08 08:20:08" itemprop="dateModified" datetime="2019-01-08T08:20:08+08:00">2019-01-08</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>EffectiveObjective-C2.0 笔记 - 第六部分</strong></p>
<h1 id="6-块与大中枢派发"><a href="#6-块与大中枢派发" class="headerlink" title="6. 块与大中枢派发"></a>6. 块与大中枢派发</h1><h2 id="6-1-理解-“块”-这一概念"><a href="#6-1-理解-“块”-这一概念" class="headerlink" title="6.1 理解 “块” 这一概念"></a>6.1 理解 “块” 这一概念</h2><p><strong>一、块的基础知识</strong></p>
<p>块是C、C++、Objective-C 中的词法闭包。</p>
<p><strong>1. 块用 “^” 符号来表示，后面跟着一对花括号，括号里面是块的实现代码。</strong></p>
<blockquote>
<p>块其实就是个值，与 int，flout，Objective-C对象一样，而且自有其相关类型，可以赋值给变量；块类型的语法和函数指针类似。</p>
</blockquote>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">^&#123;</span><br><span class="line">	//block implementation herer	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//块类型的语法结构如下</span><br><span class="line">//return_type (^block_name)(parameters)</span><br><span class="line">void (^oneBlock)() = ^&#123;</span><br><span class="line">	//block implementation herer	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2. 在声明块的范围内，所有变量都可以被其捕获。</strong></p>
<blockquote>
<p>默认情况下被块捕获的变量是不可以在块里修改的，不过可以在声明变量的时候加上__block 修饰符，这样子就可以在块内修改了。</p>
</blockquote>
<blockquote>
<p>如果块所捕获的变量是对象类型，那么就会自动保留它，在系统释放这个块的时候，也会将其一并释放。</p>
</blockquote>
<blockquote>
<p>块总能修改实例变量，所以在声明时无须加__block。不过如果通过读取或写入操作捕获了实例变量，那么也会自动把self 变量一并捕获了，因为实例变量是与self 所指代的实例关联在一起的。</p>
</blockquote>
<blockquote>
<p>如果 self 所指代的那个对象同时也保留了块，那么这种情况通常就会导致”保留环”。</p>
</blockquote>
<p><strong>二、块的内部结构</strong></p>
<p><strong>1. 块本身也是对象，在存放块对象的内存区域中，首个变量是指向Class 对象的指针(isa 指针)。</strong></p>
<p>   <img src="http://qnyunyun.yunsoho.cn/adadsa.png" alt=""></p>
<p><strong>2. invoke 变量是这个函数指针，指向块的实现代码。</strong></p>
<blockquote>
<p>函数原型至少要接受一个void* 型的参数，此参数代表块。为什么要把块对象作为参数传进来呢，因为在执行块的时候，要从内存中把这些捕获到的变量读出来。</p>
</blockquote>
<blockquote>
<p>descriptor 变量是指向结构体的指针，这个结构体包含块的一些信息。</p>
</blockquote>
<p><strong>三、全局块、栈块及堆块</strong></p>
<p><strong>1. 定义块的时候，其所占的内存区域是分配在栈中，意思就是，块只在定义它的那个范围内有效。</strong></p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void (^block)();</span><br><span class="line">if(***)&#123;</span><br><span class="line">	block = ^()&#123;</span><br><span class="line">		NSLog(@&quot;Block A&quot;);</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">	block = ^()&#123;</span><br><span class="line">		NSLog(@&quot;Block B&quot;);</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line">block();</span><br></pre></td></tr></table></figure>
<ul>
<li>栈块</li>
</ul>
<blockquote>
<p>定义在if else 语句中的两个块都分配在栈内存中，编译器会给每个块分配好栈内存，然而等离开了相应的范围之后，编译器有可能把分配给块内存覆写掉。所以这里执行block() 有危险。</p>
</blockquote>
<ul>
<li>堆块</li>
</ul>
<blockquote>
<p>为了解决这个问题，可以给块发送copy 消息以拷贝之。这样子的话，就可以把块从栈复制到堆可。一旦复制到堆上，块就成了带引用计数的对象了，后续的复制操作都不会真的执行复制，只是递增块对象的引用计数。</p>
</blockquote>
<ul>
<li>全局块</li>
</ul>
<blockquote>
<p>全局块声明在全局内存里，而且也不能被系统回收，相当于单例。由于运行该块所需的全部信息在编译期确定，所以可以把它作为全局块，这是一种优化技术：若把如此简单的块当成复杂的块来处理，那就会在复制及丢弃该块时执行一些无谓的操作。</p>
</blockquote>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void (^block)() = ^()&#123;</span><br><span class="line">		NSLog(@&quot;Block A&quot;);</span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="6-2-为常用的块类型创建-typedef"><a href="#6-2-为常用的块类型创建-typedef" class="headerlink" title="6.2 为常用的块类型创建 typedef"></a>6.2 为常用的块类型创建 typedef</h2><p><strong>1. 每个块都具备其 “固定类型”，因而可将其赋值给适当类型的变量。</strong></p>
<p><strong>2. 由于块类型的语法比较复杂难记，我们可以给块类型起个别名。</strong></p>
<blockquote>
<p>用C 语言中的 “类型定义” 的特性。typedef 关键字用于给类型起个易读的别名。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef int(^EOCSomeBlock)(BOOL flag, int value);</span><br><span class="line"></span><br><span class="line">EOCSomeBlock block = ^(BOOL flag, int value)&#123;</span><br><span class="line">	//to do</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="6-3-块降低代码分散程度"><a href="#6-3-块降低代码分散程度" class="headerlink" title="6.3 块降低代码分散程度"></a>6.3 块降低代码分散程度</h2><p><strong>场景：</strong></p>
<blockquote>
<p>异步方法执行完任务，需要以某种手段通知相关代码。经常使用的技巧是设计一个委托协议，令关注此事件的对象遵从该协议，对象成了delegate 之后，就可以在相关事件发生时得到通知了。</p>
</blockquote>
<p><strong>使用块来写的话，代码会更清晰，使得代码更加紧致。</strong></p>
<h2 id="6-4-用块引用其所属对象时不要出现保留环"><a href="#6-4-用块引用其所属对象时不要出现保留环" class="headerlink" title="6.4 用块引用其所属对象时不要出现保留环"></a>6.4 用块引用其所属对象时不要出现保留环</h2><p><strong>1. 如果块所捕获的对象直接或间接地保留了块本身，那么就得当心保留环问题。</strong></p>
<p><strong>2. 一定要找个合适的时机解除保留环，而不能把责任推给API的调用者。</strong></p>
<h2 id="6-5-多用派发队列，少用同步锁"><a href="#6-5-多用派发队列，少用同步锁" class="headerlink" title="6.5 多用派发队列，少用同步锁"></a>6.5 多用派发队列，少用同步锁</h2><p><strong>1. 同步锁</strong></p>
<blockquote>
<p>如果有多个线程要执行同一份代码，那么有时可能会出问题，这种情况下，通常要使用锁来实现某种同步机制。在GCD 出现之前，有两种办法：</p>
</blockquote>
<ul>
<li><p>采用内置的 “同步块”（synchronization block）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (void)synchronizedMethod &#123;</span><br><span class="line">	@synchronized(self)&#123;</span><br><span class="line">		//safe</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">这种写法会根据给定的对象，自动创建一个锁，并等待块中的代码执行完毕，执行到代码结尾，锁就释放了。</span><br><span class="line"></span><br><span class="line">但是，滥用 @synchronized(self) 则会降低代码效率，因为共用同一个锁的那些同步块，都必须按顺序执行。</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
</li>
<li><p>直接使用NSLock 对象，也可以使用NSRecursiveLock “递归锁”，线程能多次持有该锁，而且不会出现死锁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_lock = [[NSLock alloc] init];</span><br><span class="line"></span><br><span class="line">- (void)synchronizedMethod &#123;</span><br><span class="line">	[_lock lock];</span><br><span class="line">	//safe</span><br><span class="line">	[_lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>2. 对于上面两种方法，有些缺陷，同步块会导致死锁，直接使用锁对象，遇到死锁，就会非常麻烦。</strong></p>
<p><strong>3. GCD以更简单、更高效的形式为代码加锁。</strong></p>
<p><strong>例子：</strong></p>
<blockquote>
<p>属性是开发者经常需要同步的地方，可以使用atomic 特质来修饰属性，来保证其原子性，每次肯定可以从中获取到有效值，然而在同一个线程上多次调用获取方法(getter)，每次获取到结果未必相同，在两次访问操作之间，其他线程可能会写入新的属性值。</p>
</blockquote>
<p>   使用 “串行同步队列”，将读取操作及写入操作都安排在同一个队列里，即可保证数据同步。</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">_syncQueue = dispatch_queue_create(&quot;com.yun.syncQueue&quot;, NULL);</span><br><span class="line"></span><br><span class="line">- (NSString *)name &#123;</span><br><span class="line">    __block NSString *rstName;</span><br><span class="line">    dispatch_sync(_syncQueue, ^&#123;</span><br><span class="line">        rstName = _name;</span><br><span class="line">    &#125;);</span><br><span class="line">    return rstName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setName:(NSString *)name &#123;</span><br><span class="line">    dispatch_sync(_syncQueue, ^&#123;</span><br><span class="line">        _name = name;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面是用串行同步队列来保证数据同步：把设置操作与获取操作都安排在序列化的串行同步队列里执行，这样子，所有针对属性的访问操作都是同步的了。</p>
</blockquote>
<blockquote>
<p>进一步优化，设置方法不一定非得是同步的，因为不需要返回值。这样子可以提高设置方法的执行速度，而读取操作与写入操作依然会按照顺序执行。</p>
</blockquote>
<p><strong>优化：多个获取方法可以并发执行，而获取方法与设置方法不能并发执行。</strong></p>
<p>   我们还可以使用并发队列来实现,现在都是在并发队列上面执行任务，但是顺序不能控制，我们可以用栅栏(barrier)来解决。</p>
<p>   这两个函数可以向队列派发块，将其作为栅栏来使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dispatch_barrier_sync(dispatch_queue_t queue,^(void)block)</span><br><span class="line">dispatch_barrier_async(dispatch_queue_t queue,^(void)block)</span><br></pre></td></tr></table></figure>
<p>   在队列中，栅栏块必须单独执行，不能与其他块并行，这只对并发队列有意义，因为串行队列中的块总是按照顺序逐个执行的。并发队列如果发现接下来要处理的块是栅栏块，那么就一直要等到当前所有的并发块都执行完毕，才会单独执行这个栅栏块。执行完栅栏块，再按照正常方式向下处理。<br>   */</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">-----&gt; 现在并发队列 还不能满足要求</span><br><span class="line">_syncQueue1 = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">- (NSString *)name &#123;</span><br><span class="line">    __block NSString * rstName;</span><br><span class="line">    dispatch_sync(_syncQueue1, ^&#123;</span><br><span class="line">        rstName = _name;</span><br><span class="line">    &#125;);</span><br><span class="line">    return rstName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setName:(NSString *)name &#123;</span><br><span class="line">    dispatch_async(_syncQueue1, ^&#123;</span><br><span class="line">        _name = name;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-----&gt; 转换写法 用栅栏块控制属性的设置方法 不能并行</span><br><span class="line">_syncQueue1 = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">- (NSString *)name &#123;</span><br><span class="line">    __block NSString * rstName;</span><br><span class="line">    dispatch_sync(_syncQueue1, ^&#123;</span><br><span class="line">        rstName = _name;</span><br><span class="line">    &#125;);</span><br><span class="line">    return rstName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setName:(NSString *)name &#123;</span><br><span class="line">    dispatch_barrier_async(_syncQueue1, ^&#123;</span><br><span class="line">        _name = name;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-6-多用GCD，少用performSelector-方法"><a href="#6-6-多用GCD，少用performSelector-方法" class="headerlink" title="6.6 多用GCD，少用performSelector 方法"></a>6.6 多用GCD，少用performSelector 方法</h2><p><strong>建议用GCD 替代performSelector，对于performSelector 遇到的问题，我们都可以用GCD 解决</strong></p>
<ol>
<li><p>performSelector 可以任意调用方法，还可以延迟调用，还可以指定运行方法所用的线程，这些由 Objective-C 的动态性决定。</p>
</li>
<li><p>但是如果是动态来调用performSelector 方法的时候，编译器都不知道执行的选择子是什么，必须到了运行期才能确定，这种情况在ARC下会报警告，因为编译器不知道方法名，所以不能运用ARC内存管理规则来判定返回值是否应该释放，对于这种情况ARC不会帮我们添加任何释放操作。</p>
</li>
<li><p>performSelector 方法调用的时候对于返回类型只能是void或对象类型，对于有返回值的需要自己做多次转换，对于参数的也最多只能传2个，介于此performSelector 还是比较不方便的。</p>
</li>
<li><p>如果想把任务放在另一个线程上执行，那么最好不要用performSeletor  系列方法，而是应该把任务封装到块里，然后调用大中枢派发机制的相关方法来实现。</p>
</li>
</ol>
<h2 id="6-7-掌握GCD-及操作队列的使用时机"><a href="#6-7-掌握GCD-及操作队列的使用时机" class="headerlink" title="6.7 掌握GCD 及操作队列的使用时机"></a>6.7 掌握GCD 及操作队列的使用时机</h2><p><strong>1. 使用NSOperation执行后台任务</strong></p>
<ul>
<li><p>GCD在很多地方特别优秀，但是在执行后台任务时，GCD不一定是最佳方式，还有一种技术叫做NSOperationQueue，开发者可以把操作以NSOperation子类的形式放在队列中，而这些操作也可以并发执行。</p>
</li>
<li><p>GCD是纯C的API，操作队列的则是Objective-C的对象。用NSOperationQueue类的“addOperationWithBlock” 方法搭配NSBlockOperation类操作队列，其语法与纯GCD方式非常类似。使用NSOperation及NSOperationQueue 的好处如下：</p>
</li>
</ul>
<p><strong>1) 取消某个操作。</strong></p>
<blockquote>
<p>如果使用操作队列，那么想取消操作是很容易的。运行任务之前，可以在NSOperation 对象调用cancel 方法，该方法会设置对象内的标识位，用以表明此任务不需执行，不过，已经启动的任务无法取消。若不是操作队列，而是把块安排到GCD 队列，那就无法取消了。那套架构是 “安排好任务之后就不管了”。开发者可以在应用层自己来实现取消功能，不过这样子做需要编写很多代码，而那些代码其实已经由操作队列实现好了。</p>
</blockquote>
<p><strong>2. 指定操作间的依赖关系。</strong></p>
<blockquote>
<p>一个操作可以依赖其他多个操作。开发者能够指定操作之间的依赖关系，使特定的操作必须在另外一个操作顺序执行完毕方可执行，比方说，从服务器下载并处理文件的动作，可以用操作来表示，而在处理其他文件之前，必须先下载 “清单文件”。后续的下载操作，都要依赖于先下载清单文件这一操作。如果操作队列允许并发的话，那么后续的多个下载操作就可以同时执行，但前提是它们所依赖的那个清单文件下载操作已经执行完毕。</p>
</blockquote>
<p><strong>3. 通过键值观测机制监控NSOperation对象的属性。</strong></p>
<blockquote>
<p>NSOperation 对象有许多属性都适合通过键值观测机制（KVO）来监听，比如可以通过isCancalled 属性来判断任务是否取消。如果想在某个任务变更期状态时得到通知，或是想用比GCD 更为精细的方式来控制所要执行的任务，那么键值观测机制会很有用。</p>
</blockquote>
<p><strong>4. 制定操作的优先级。</strong></p>
<blockquote>
<p>操作的优先级表示此操作与队列其他操作之间的优先关系。优先级高的操作先执行，优先级低的后执行。操作队列的调度算法已经比较成熟。反之，GCD 则没有直接实现此功能的办法，GCD 的队列有优先级，但是是针对整个队列来说的，而不是针对每个块来说的。对于优先级这一点，操作队列所提供的功能比GCD 更为便利。</p>
</blockquote>
<p><strong>5. 重用NSOperation 对象。</strong></p>
<blockquote>
<p>系统内置类一些NSOperation 的子类供开发者调用，要是不想用这些固有子类的话，那就得自己来创建了。这些类就是普通的Objective-C 对象，能够存放任何信息。对象在执行时可以充分利用存于其中的信息，而且还可以随意调用定义在类中的方法。这比派发队列中哪些简单的块要强大。这些NSOperation 类可以在代码中多次使用。</p>
</blockquote>
<h2 id="6-8-通过Dispatch-Group机制，根据系统资源状况来执行任务"><a href="#6-8-通过Dispatch-Group机制，根据系统资源状况来执行任务" class="headerlink" title="6.8 通过Dispatch Group机制，根据系统资源状况来执行任务"></a>6.8 通过Dispatch Group机制，根据系统资源状况来执行任务</h2><p><strong>1. 一系列任务可归入一个dispatch group之中。开发者可以在这组任务执行完毕时获得通知。</strong></p>
<p><strong>2. 通过dispatch group，可以在并发式派发队列里同时执行多项任务。此时GCD会根据系统资源状况来调度这些并发执行的任务。开发者若自己实现此功能，则需编写大量代码。</strong></p>
<h2 id="6-9-使用dispatch-once来执行只需运行一次的线程安全代码"><a href="#6-9-使用dispatch-once来执行只需运行一次的线程安全代码" class="headerlink" title="6.9 使用dispatch_once来执行只需运行一次的线程安全代码"></a>6.9 使用dispatch_once来执行只需运行一次的线程安全代码</h2><ol>
<li>只需执行一次的线程安全代码时，使用dispatch_once。</li>
</ol>
<blockquote>
<p>经常需要编写 “只需执行一次的线程安全代码”。通常使用GCD 所提供的dispatch_once 函数，很容易就能实现此功能。</p>
</blockquote>
<blockquote>
<p>使用dispatch_once 可以简化代码，并且彻底保证线程安全</p>
</blockquote>
<ol>
<li>单例示例</li>
</ol>
<blockquote>
<p>对于单例我们创建唯一实例，之前都是用@synchronized 加锁来解决多线程的问题，GCD 提供了一个更加简单的方法来实现。    </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//单例</span><br><span class="line">+(instancetype)shareInstance&#123;</span><br><span class="line">    static EOCClass *shareInstance;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        shareInstance = [EOCClass new];</span><br><span class="line">    &#125;);</span><br><span class="line">    return shareInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-10-不要使用dispatch-get-current-queue"><a href="#6-10-不要使用dispatch-get-current-queue" class="headerlink" title="6.10 不要使用dispatch_get_current_queue"></a>6.10 不要使用dispatch_get_current_queue</h2><ol>
<li><p>dispatch_get_current_queue 函数的行为常常与开发者所预期的不同。此函数已经废弃(iOS 6.0起废除)，只应做调试之用。</p>
</li>
<li><p>由于派发队列是按层级来组织的，所以无法单用某个队列对象来描述 “当前队列” 这一概念。</p>
</li>
<li><p>dispatch_get_current_queue 函数用于解决由不可重入的代码引发的死锁，然而能用此函数的解决的问题，通常也能改用 “队列特定数据” 来解决。</p>
</li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/03/iOS-book-EffectiveObjective-C2.0-chap5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yun's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/03/iOS-book-EffectiveObjective-C2.0-chap5/" itemprop="url">
                  EffectiveObjective-C2.0 笔记 - 第五部分
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-10-03 22:12:32" itemprop="dateCreated datePublished" datetime="2018-10-03T22:12:32+08:00">2018-10-03</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2018-11-05 10:03:49" itemprop="dateModified" datetime="2018-11-05T10:03:49+08:00">2018-11-05</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>EffectiveObjective-C2.0 笔记 - 第五部分</strong></p>
<h1 id="5-内存管理"><a href="#5-内存管理" class="headerlink" title="5 内存管理"></a>5 内存管理</h1><h2 id="5-1-理解引用计数"><a href="#5-1-理解引用计数" class="headerlink" title="5.1 理解引用计数"></a>5.1 理解引用计数</h2><h3 id="1、引用计数"><a href="#1、引用计数" class="headerlink" title="1、引用计数"></a>1、引用计数</h3><p>Objective-C 语言使用引用计数来管理内存，每个对象都有个可以递增递减的计数器，用以表示当前有多少个事物想令此对象继续存活下去。当这个计数器归零那么这个对象就会被释放。</p>
<blockquote>
<p>查看引用计数的方法叫做 retainCount 但是实际并不建议使用这个方法调试代码</p>
</blockquote>
<p>NSObject 协议声明下面三个方法用于操作计数器，以递增或递减其值：</p>
<ul>
<li>retain 递增保留计数</li>
<li>release 递减保留计数</li>
<li>autorelease 待稍后清理 “自动释放池” 时，再递减保留计数</li>
</ul>
<p>在调用release 之后，对象所占的内存可能会被回收，这样子在调用对象的方法就可能使程序崩溃，这里 “可能” 的意思是对象所占的内存在 “解除分配” （deallocated）之后，只是放回 “可用内存池”（avaiable pool）。若果执行方法时尚未覆写对象，那么对象仍然有效。</p>
<p>为避免在不经意间使用无效对象，一般在调用完release 之后都会清空指针，保证不会出现可能指向无效对象的指针，这种指针通常被称为 “悬挂指针”（dangling pointer）。</p>
<p>所有的对象最终都间接或直接的被一个根对象所引用，macOS 应用是 NSApplication 对象，iOS 则是 UIApplication 对象，这两个对象都是应用启动时创建的单例</p>
<h3 id="2、自动释放池-autorelease"><a href="#2、自动释放池-autorelease" class="headerlink" title="2、自动释放池 autorelease"></a>2、自动释放池 autorelease</h3><p>调用release 会立刻递减对象的保留计数（这里可能会令系统回收此对象），调用autorelease 方法，并不会马上减少对象的引用计数，而是在下一次 Event Loop（事件循环）时减少，以达到延迟释放对象的效果。</p>
<p>autorelease 能延长对象声明周期，使其在跨越方法调用边界后依然可以存活一段时间。</p>
<p>调用 release 并不会使对象被释放，对象释放被释放取决于引用计数是否为 0</p>
<h2 id="5-2-以-ARC-简化引用计数"><a href="#5-2-以-ARC-简化引用计数" class="headerlink" title="5.2 以 ARC 简化引用计数"></a>5.2 以 ARC 简化引用计数</h2><p><strong>1. 内存泄漏：</strong></p>
<blockquote>
<p>没有正确的释放已经不再使用的内存。</p>
</blockquote>
<p><strong>2. ARC自用引用计数</strong></p>
<p><strong>1) ARC 只是自动为代码添加内存管理相关的代码</strong></p>
<blockquote>
<p>ARC 是通过在编译时在我们的代码中插入对应的内存管理代码，并且只适用于 Objective-C 的代码，使用ARC 时，引用计数实际上还是要执行的，只是保留与释放操作是由ARC 自动添加的。</p>
</blockquote>
<p><strong>2) 在 ARC 下，不允许调用内存管理方法 retain，release，autorelease，dealloc</strong></p>
<blockquote>
<p>ARC会自动执行以下等操作，所以在ARC下调用这些内存管理方法是<strong>非法的</strong>。</p>
</blockquote>
<ul>
<li>retain</li>
<li>release</li>
<li>autorelease</li>
<li>dealloc</li>
</ul>
<blockquote>
<p>ARC 在调用这些方法时，并不是普通的Objective-C 消息派发机制，而是直接调用其底层的C 语言函数，这样子性能会更好。</p>
</blockquote>
<p><strong>3. 使用ARC 时必须遵循的方法命名规则</strong></p>
<p>将内存管理语义在方法名中表示出来，若方法名以下列词语开头，则返回的对象归调用者所有：</p>
<ul>
<li>alloc</li>
<li>new</li>
<li>copy</li>
<li>mutableCopy</li>
</ul>
<p><strong>4. 变量的内存管理语义</strong></p>
<p><strong>1) ARC 也会处理局部变量与实例变量的内存管理。</strong></p>
<p><strong>2 )我们通常会给局部变量加上修饰符来打破 “块”（block）所引入的 “保留环”（retain cycle）。</strong></p>
<p>变量内存管理语义修饰符</p>
<ul>
<li>__strong：默认，强引用，表示需要保留这个值</li>
<li>__weak：弱引用，表示不保留这个值，并且如果系统回收这个对象，那么在获取此变量的值的时候会的到 nil</li>
<li>__unsafe_unretained：不安全的引用，不保留此值，系统回收这个对象的时候，不会清空变量的值</li>
<li>__autoreleasing：把对象“按引用传递”给方法时使用，表示此值在方法返回时自动释放</li>
</ul>
<p><strong>5. ARC 如何清理实例变量</strong></p>
<p>对实例变量进行内存管理，必须在 “回收分配给对象的内存” 时生成必要的清理代码。凡事具备强引用的变量，都必须释放，ARC 会在dealloc 方法中插入这些代码。</p>
<ul>
<li>ARC 只负责管理Objective-C 对象的内存</li>
</ul>
<blockquote>
<p>ARC 会借用Objective-C++ 的一项特性来生成清理代码，在回收对象时，待回收对象会调用所有C++ 对象的析构函数，编译器如果发现某个对象里含有C++ 对象，就会生成名为.cxx_desteuct 的方法，ARC 借助此特性，在该方法中生成清理内存所需的代码。</p>
</blockquote>
<ul>
<li>对于非Objective-C 的对象，需要我们手动清理。</li>
</ul>
<blockquote>
<p>如 CoreFoundation 对象不归ARC 管理，开发者必须适时调用CFRetain/CFRelease。</p>
</blockquote>
<p><strong>6. 覆写内存管理方法</strong></p>
<p>非ARC 时可以覆写内存管理方法，在ARC 下禁止覆写内存管理方法，会干扰到ARC 分析对象生命周期的工作。</p>
<h2 id="5-3-在-dealloc-方法中只释放引用，并解除监听"><a href="#5-3-在-dealloc-方法中只释放引用，并解除监听" class="headerlink" title="5.3 在 dealloc 方法中只释放引用，并解除监听"></a>5.3 在 dealloc 方法中只释放引用，并解除监听</h2><p>对象在经历生命周期后，最终会为系统回收，这时候就要执行dealloc 方法。每个对象生命周期内，此方法只会调用一次，也就是保留计数为0 的时候，绝对不能自己调用dealloc 方法，运行期会在适当的时候调用，一旦调用，对象就不再有效了，后续的方法调用均是无效的。</p>
<p>dealloc 方法主要是释放对象所拥有的引用，也就是把Objective-C 对象都释放掉，ARC 会通过自动生成的.cxx_desteuct 方法，在dealloc 中为你自动添加这些释放代码。但是其他非Objective-C 对象就需要自己手动释放了。</p>
<p><strong>1. dealloc 方法中需要做的事情：</strong></p>
<ul>
<li>释放对象所拥有的引用，持有的对象(ARC 下自动加入施放代码)</li>
<li>清理观察者</li>
<li>清理通知</li>
<li>如果不使用 ARC，那么需要调用 [super dealloc] 方法</li>
</ul>
<p><strong>2. dealloc 方法中不适合做的事情：</strong></p>
<ul>
<li>释放开销较大或系统内稀缺的资源（文件描述符，套接字，大量内存等）</li>
</ul>
<blockquote>
<p>因为 dealloc 方法并不会在特定时机调用，一般对于使用这样资源的对象都需要提供名字类似 open 和 close 的方法处理申请和释放资源的行为</p>
</blockquote>
<ul>
<li>执行异步任务</li>
</ul>
<blockquote>
<p>异步方法执行后，对象可能已经施放</p>
</blockquote>
<ul>
<li>尽量不要去调用方法，包括属性的存取方法</li>
</ul>
<blockquote>
<p>在dealloc 里尽量不要去调用方法，包括属性的存取方法，因为在这些方法可能会被覆写，并在其中做一些无法在回收阶段安全执行的操作。</p>
</blockquote>
<h2 id="5-4-编写-“异常安全代码”-时留意内存管理问题"><a href="#5-4-编写-“异常安全代码”-时留意内存管理问题" class="headerlink" title="5.4 编写 “异常安全代码” 时留意内存管理问题"></a>5.4 编写 “异常安全代码” 时留意内存管理问题</h2><p><strong>1. C++ 和 Objective-C 的异常互相兼容，可以相互抛出捕获</strong></p>
<blockquote>
<p>纯C 中没有异常，C++与Objective-C 都支持异常，在运行期系统中C++与Objective-C 异常相互兼容，也就是说，从其中一门语言里抛出的异常能用另外一门语言所编写的 “异常处理程序” 来捕获。</p>
</blockquote>
<p><strong>2. 捕获异常时，一定要注意将try 块内创建的对象清理干净。</strong></p>
<blockquote>
<p>Objective-C 错误模型表明，异常只应发生严重错误后抛出，发生异常如何管理内存很重要，在try 块中保留某个对象的，但是在释放它之前抛出异常了，这时候就无法正常释放了，这时候需要借助@finally 块来保证释放对象的代码一定会执行，且只执行一次。</p>
</blockquote>
<p><strong>3. 默认情况下，ARC 不生成安全处理异常所需的清理代码。</strong></p>
<blockquote>
<p>在ARC 不会自动生成处理异常中的代码，因为这样子需要加入大量的样板代码，以便追踪待清理的对象，从而在抛出异常时将其释放。可以这段代码会严重运行期的性能，还会增加应用程序的大小。</p>
</blockquote>
<blockquote>
<p>可以通过<code>-fobjc-arc-exceptions</code> 这个编译编织来开启这个功能，但是这个功能不应该作为生成这种安全处理异常所用的附加代码，应该是让代码处于Objective-C++模式。</p>
</blockquote>
<h2 id="5-5-以弱引用避免保留环"><a href="#5-5-以弱引用避免保留环" class="headerlink" title="5.5 以弱引用避免保留环"></a>5.5 以弱引用避免保留环</h2><p><strong>1. 相互引用和对象引用环</strong></p>
<blockquote>
<p>几个对象都以某种方式互相引用，从而形成 “环”，这种情况通常会泄漏内存，因为没有东西引用环中对象，这样子环里的对象互相引用，不会被系统回收，会导致内存泄漏。</p>
</blockquote>
<p><strong>2. 避免保留环的最佳方式就是弱引用</strong></p>
<ul>
<li>非 ARC 的情况下使用 assign 或者 unsafe_unretained 来修饰弱引用属性</li>
<li>ARC 的情况下使用 weak 来修饰弱引用的属性，因为 weak 的属性在对象被释放后会自动设置为 nil</li>
</ul>
<blockquote>
<p>一般来说，如果不拥有某对象，就不要保留它，这条规则对collection 例外，collection 虽然不直接拥有其内容，但是它要代表自己所属的那个对象来保留这些元素。</p>
</blockquote>
<h2 id="5-6-以-“自动释放池块”-降低内存峰值"><a href="#5-6-以-“自动释放池块”-降低内存峰值" class="headerlink" title="5.6 以 “自动释放池块” 降低内存峰值"></a>5.6 以 “自动释放池块” 降低内存峰值</h2><p><strong>1. 释放对象有两种方式：</strong></p>
<p><strong>1) 一种是调用release 方法，使其保留计数立即递减</strong></p>
<blockquote>
<p>ARC下不能主动调用</p>
</blockquote>
<p><strong>2) 一种是调用autorelease 方法</strong></p>
<blockquote>
<p>将对象放入 “自动释放池” 中，自动释放池用于存放那些需要稍后某个时刻释放的对象，清空（drain）自动释放池时，系统会向其中的对象发送release 消息。</p>
</blockquote>
<blockquote>
<p>创建自动释放池，系统会自动创建一些线程，这些线程默认都有自动释放池，每次执行 “事件循环”时，都会将其清空。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@autoreleasepool &#123;</span><br><span class="line">//...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2. 内存峰值：</strong></p>
<blockquote>
<p>是指应用程序在某个特定时段内的最大内存用量。如：循环创建大量对象的时候</p>
</blockquote>
<ul>
<li>对象有可能会放在自动释放池里面，需要等到线程执行下一次事件循环才会清空，这里会导致应用程序所占内存会持续增加，等到临时对象释放的时候，内存用量又会突然下降。我们现在就想把这个内存峰值给降低下来。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0;i &lt; 100000;i++)&#123;</span><br><span class="line">    @autorelease&#123;</span><br><span class="line">        NSObject *object = [NSObject new];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-7用-“僵尸对象”-调试内存管理问题"><a href="#5-7用-“僵尸对象”-调试内存管理问题" class="headerlink" title="5.7用 “僵尸对象” 调试内存管理问题"></a>5.7用 “僵尸对象” 调试内存管理问题</h2><p><strong>1. 僵尸对象用于调试代码是否会使用到已经被销毁的对象</strong></p>
<blockquote>
<p>向已回收的对象发送消息是不安全的，是否崩溃这个是看对象所占的内存有没有为其他内容所覆写。</p>
</blockquote>
<ul>
<li>Cocoa 提供 “僵尸对象”（Zombie Object）这个非常方便的功能，开启后，运行期系统会把已经回收的实例转换成特殊的 “僵尸对象”，而不会真正回收它们。这个对象所在的核心内无法重用，因此不可能遭到覆写，僵尸对象收到消息后，会抛出异常。</li>
</ul>
<p><strong>2. XCODE 设置</strong></p>
<blockquote>
<p>Xcode Scheme 中的Enable Zombie Objects 选项，打开会将NSZombieEnabled 环境变量设成YES。</p>
</blockquote>
<ul>
<li><p>系统在即将回收时，会执行一个附加步骤，将对象转换成僵尸对象，而不彻底回收。僵尸类是从名为<em>NSZombie</em> 的模版类复制出来的。<em>NSZombie</em> 类并未实现任何方法，此类没有超类，因此跟NSObject 一样，也是一个 “根类”，该类只有一个实例变量，叫做isa，所以发给他的消息都要经过 “完整的消息转发机制” 。</p>
</li>
<li><p>在完整的消息转发机制中，<strong><em>forwarding</em></strong> 是核心，检查接受消息的对象所属的类名，若是<em>NSZombie</em> ，则表示消息接受者是僵尸对象，需要特殊处理。</p>
</li>
<li><p>系统在回收对象时，可以不将其真的回收，而是把它转化成僵尸对象。通过环境变量NSZombieEnabled 可开启此功能。</p>
</li>
<li><p>系统会修改对象的isa 指针，令其指向特殊的僵尸类，从而使该对象变成僵尸对象。僵尸类能够响应所有的选择子，响应方式为：打印一条包含消息内容及其接受者的消息，然后终止应用程序。</p>
</li>
</ul>
<h2 id="5-8-不要使用-retainCount"><a href="#5-8-不要使用-retainCount" class="headerlink" title="5.8 不要使用 retainCount"></a>5.8 不要使用 retainCount</h2><p><strong>1. retainCount 在反映调用者有多少对象引用，以及调试内存管理都没有任何帮助</strong></p>
<ul>
<li>每个对象都有一个计数器，其表明还有多少个其他对象想令此对象继续存活。在ARC retainCount 这个方法已经废弃了，但是在非ARC 中也不应该调用这个方法，因为这个保留计数只是返回某个时间点的值，并不会联系上下文给出真正有用的值。</li>
</ul>
<p><strong>2. retainCount 在 ARC 环境下将会编译错误</strong></p>
<ul>
<li><p>retainCount 可能永远不返回0，因为系统有时候会优化对象的释放行为，在保留计数为1的时候就把它回收了。</p>
</li>
<li><p>不应该依靠保留计数的具体址来编码。</p>
</li>
<li><p>对象的保留计数看似有用，实则不然，因为任何给定时间点上的 “绝对保留计数”（absolute retain count）都无法反映对象生命期的全貌。</p>
</li>
<li><p>引入ARC 之后，retainCount 方式就正式废止了，在ARC 下调用方法会导致编译器报错。</p>
</li>
</ul>
<p><strong>3. 发布版本时，一定关闭此功能</strong></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/24/iOS-book-EffectiveObjective-C2.0-chap4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yun's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/24/iOS-book-EffectiveObjective-C2.0-chap4/" itemprop="url">
                  EffectiveObjective-C2.0 笔记 - 第四部分
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-09-24 20:11:32" itemprop="dateCreated datePublished" datetime="2018-09-24T20:11:32+08:00">2018-09-24</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2018-11-05 10:03:49" itemprop="dateModified" datetime="2018-11-05T10:03:49+08:00">2018-11-05</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>EffectiveObjective-C2.0 笔记 - 第四部分</strong></p>
<h1 id="4-协议与分类"><a href="#4-协议与分类" class="headerlink" title="4 协议与分类"></a>4 协议与分类</h1><h2 id="4-1-通过委托与数据源协议进行对象间通信"><a href="#4-1-通过委托与数据源协议进行对象间通信" class="headerlink" title="4.1 通过委托与数据源协议进行对象间通信"></a>4.1 通过委托与数据源协议进行对象间通信</h2><p><strong>1. 协议（protocol）类似 java 的接口（interface）。Objective-C 不支持多重继承，但我们可以把某个类应该实现的方法定义在一系列的协议里面。</strong></p>
<ol>
<li>Objective-C 可以使用 “委托模式”（Delegate pattern）的编程设计模式来实现对象间的通信：</li>
</ol>
<blockquote>
<p>定义一套接口，某对象若想接受另一个对象的委托，则需遵从此接口，以便成为其 “委托对象”（delegate）。Objective-C 一般利用 “协议” 机制来实现此模式。</p>
</blockquote>
<p>定义协议：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//采用 “驼峰法” 命名，最后加上 Delegate 一词</span><br><span class="line">@protocol EOCNetworkingFetcherDelegate&lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">// 可选实现的方法</span><br><span class="line">@optional</span><br><span class="line">- (void)newworkingFetcher:(EOCNetworkingFetcher *)fetcher</span><br><span class="line">            didRecevieData:(NSData *)data;</span><br><span class="line"></span><br><span class="line">// 必须实现的方法</span><br><span class="line">@required</span><br><span class="line">- (void)newworkingFetcher:(EOCNetworkingFetcher *)fetcher</span><br><span class="line">         didFailWithError:(NSError *)error;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface EOCNetworkingFetcher : NSObject</span><br><span class="line"></span><br><span class="line">// weak，避免循环引用</span><br><span class="line">@property (nonatomic,weak) id delegate;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p><strong>3. 如果要在委托对象上调用可选方法，那么必须提前使用类型信息查询方法，判断这个委托对象能否响应相关的选择子。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSData *data;</span><br><span class="line">if([_delegate respondsToSelector:@selector(networkFetcher:didRecevieData:)])&#123;</span><br><span class="line">    [_delegate networkFetcher:self didRecevieData:data];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4. delegate 里的方法也可以用于从委托对象中获取信息（数据源模式）。</strong></p>
<p><strong>5. 在实现委托模式和数据源模式的时，协议中的方法是可选的，我们就会写出大量这种判断代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if([_delegate respondsToSelector:@selector(networkFetcher:didRecevieData:)])&#123;</span><br><span class="line">    [_delegate networkFetcher:self didRecevieData:data];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每次调用方法都会判断一次，其实除了第一次检测的结构有用，后续的检测很有可能都是多余的，因为委托对象本身没变，不太可能会一下子不响应，一下子响应的，所以我们这里可以把这个委托对象能否响应某个协议方法记录下来，以优化程序效率。<br>将方法响应能力缓存起来的最佳途径是使用 “位段”（bitfield）数据类型。我们可以把结构体中某个字段所占用的二进制位个数设为特定的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 协议</span><br><span class="line">@protocol EOCNetworkingFetcherDelegate&lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">@optional</span><br><span class="line">- (void) didReceiveData:(NSData *)data;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface EOCNetworkingFetcher ()</span><br><span class="line">// 定义位段</span><br><span class="line">struct &#123;</span><br><span class="line">    unsigned int didReceiveData : 1;</span><br><span class="line">&#125; _delegateFlags</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// 设置</span><br><span class="line">-(void)setDelegate:(id&lt;EOCNetworkingFetcherDelegate&gt;)delegate&#123;</span><br><span class="line">	_delegate = delegate;</span><br><span class="line">	_delegateFlags.didReceiveData = [_delegate respondsToSelector:@selector(didRecevieData:)]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//使用</span><br><span class="line">if(_delageteFlags.didReceiveData)&#123;</span><br><span class="line">	[_delegate didRecevieData:data];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-2-将类的实现代码分散到便于管理的数个分类之中"><a href="#4-2-将类的实现代码分散到便于管理的数个分类之中" class="headerlink" title="4.2 将类的实现代码分散到便于管理的数个分类之中"></a>4.2 将类的实现代码分散到便于管理的数个分类之中</h2><p><strong>1. 使用分类机制把类的实现代码划分成易于管理的小块。</strong></p>
<p><strong>2. 将应该视为 “私有” 的方法归入为叫Private 的分类中，以隐藏实现细节。</strong></p>
<p><strong>3. 分类原则上不能定义属性，当可以通过【关联对象】实现，参见《2.5-关联对象存放自定义数据》</strong></p>
<h2 id="4-3-总是为第三方类的分类名称加前缀"><a href="#4-3-总是为第三方类的分类名称加前缀" class="headerlink" title="4.3 总是为第三方类的分类名称加前缀"></a>4.3 总是为第三方类的分类名称加前缀</h2><p><strong>1. 分类机制常用于向无源码的既有类中新增新功能，但是在使用的时候要十分小心，不然很容易产生Bug。因为这个机制时在运行期系统加载分类时，将其方法直接加到原类中，这里要注意方法重名的问题，不然会覆盖原类中的同名方法。</strong></p>
<p><strong>2. 一般用前缀来区分各个分类的名称与其中所定义的方法。</strong></p>
<p><strong>3. 不要轻易去利用分类来覆盖方法，这里需要慎重考虑。</strong></p>
<h2 id="4-4-勿在分类中声明属性"><a href="#4-4-勿在分类中声明属性" class="headerlink" title="4.4 勿在分类中声明属性"></a>4.4 勿在分类中声明属性</h2><p><strong>1. 可以利用运行期的关联对象机制，为分类声明属性，但是这种做法要尽量避免。</strong></p>
<blockquote>
<p>因为除了 “class-continuation 分类” 之外，其他分类都无法向类中新增实例变量，因此，他们无法把实现属性所需的实例变量合成出来。</p>
</blockquote>
<p><strong>2. 利用关联对象机制可以解决分类中不能合成实例变量的问题。</strong></p>
<blockquote>
<p>自己实现存取方法，但是要注意该属性的内存管理语义（属性特质）。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic,copy) NSString *name;</span><br><span class="line">static const void *kViewControllerName = &amp;kViewControllerName;</span><br><span class="line">- (void)setName:(NSString *)name &#123;</span><br><span class="line">    objc_setAssociatedObject(self, kViewControllerName, name, OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line">- (NSString *)name &#123;</span><br><span class="line">    NSString *myName = objc_getAssociatedObject(self, kViewControllerName);</span><br><span class="line">    return myName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3. 在可以修改源代码的情况下，尽量把属性定义在主接口中。</strong></p>
<blockquote>
<p>这里是唯一能够定义实例变量的地方，属性只是定义实例变量及相关存取方法所用的 “语法糖”。</p>
</blockquote>
<h2 id="4-5-使用-”class-continuation-分类“-隐藏实现细节"><a href="#4-5-使用-”class-continuation-分类“-隐藏实现细节" class="headerlink" title="4.5 使用 ”class-continuation 分类“ 隐藏实现细节"></a>4.5 使用 ”class-continuation 分类“ 隐藏实现细节</h2><p><strong>“class-continuation 分类”必须定义在本身类的实现文件中，而且这里是唯一可以声明实例变量的分类(除关联对象机制)。</strong></p>
<blockquote>
<p>而且此分类没有特定的实现文件，这个分类也没有名字。这里可以定义实例变量的原因是 “ 稳固的ABI” 机制，我们无须知道对象的大小就可以直接使用它。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@interface EOCPerson ()</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p><strong>私有的方法、协议、变量等，都可以定义在“class-continuation 分类”</strong></p>
<p><strong>1. 可以将不需要要暴露给外界知道的实例变量及方法写在 “class-continuation 分类” 中。</strong></p>
<p><strong>2.  可以利用 “class-continuation 分类” 把引用C++ 类的细节写到实现文件中，这样子别的类引用这个类就不会受到影响，甚至都不知道这个类底层实现混有C++ 代码。</strong></p>
<blockquote>
<p>编写Objective-C++ 代码时候，使用 “class-continuation 分类” 会十分方便。因为对于引用了C++的文件的实现文件需要用.mm 为扩展名，表示编译器应该将此文件按照Objective-C++ 来编译。C++ 类必须完全引入，编译器要完整地解析其定义才能得知这个C++ 对象的实例变量大小。如果把对C++ 类的引用写在头文件的话，其他引用到这个类也会引用到这个C++ 类，就也需要编译成Objective-C++ 才行，这样子很容易失控。</p>
</blockquote>
<p><strong>3. 使用 “class-continuation 分类” 还可以将头文件声明 “只读” 的属性扩展成 “可读写”，以便在类的内部可以设置其值。</strong></p>
<blockquote>
<p>我们通常不直接访问实例变量，而是通过设置方法来做，因为这样子可以触发 “键值观测” （Key-Value Observing，KVO）通知。</p>
</blockquote>
<p><strong>4. 若对象所遵循的协议只应视为私有，也可以同过“class-continuation 分类” 来隐藏。</strong></p>
<h2 id="4-6-通过协议提供匿名对象"><a href="#4-6-通过协议提供匿名对象" class="headerlink" title="4.6 通过协议提供匿名对象"></a>4.6 通过协议提供匿名对象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic,weak) id delegate;</span><br></pre></td></tr></table></figure>
<p>该属性类型是id的，所以实际上任何类的都能充当这一属性，即便该类不继承NSObject 也可以，只要遵循EOCDelegae 协议就可以了，对于具备此属性的类来说，delegate 就是 “匿名的”。</p>
<p><strong>1. 使用匿名对象来隐藏类型名称（或类名）。</strong></p>
<p><strong>2. 如果具体类型不重要，重要的是对象能够响应（定义在协议里的）特定方法，那么可使用匿名对象来表示。</strong></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/20/iOS-book-EffectiveObjective-C2.0-chap3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yun's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/20/iOS-book-EffectiveObjective-C2.0-chap3/" itemprop="url">
                  EffectiveObjective-C2.0 笔记 - 第三部分
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-09-20 14:12:31" itemprop="dateCreated datePublished" datetime="2018-09-20T14:12:31+08:00">2018-09-20</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2018-11-05 10:03:49" itemprop="dateModified" datetime="2018-11-05T10:03:49+08:00">2018-11-05</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>EffectiveObjective-C2.0 笔记 - 第三部分</strong></p>
<h1 id="3-接口与-API-设计"><a href="#3-接口与-API-设计" class="headerlink" title="3 接口与 API 设计"></a>3 接口与 API 设计</h1><h2 id="3-1-用前缀避免命名空间冲突"><a href="#3-1-用前缀避免命名空间冲突" class="headerlink" title="3.1 用前缀避免命名空间冲突"></a>3.1 用前缀避免命名空间冲突</h2><p><strong>1.如果发生命名冲突（naming clash），那么应用程序的链接过程就会出错，因为出现了重复符号(duplicate symbol)。</strong></p>
<p><strong>2.应该为所有名称都加上适当的前缀，最好是</strong>++三个字母以上++<strong>做前缀，因为Apple宣称其保留使用所有 “两字母前缀”。</strong></p>
<p><strong>3.在类的实现文件所有的纯C 函数及全局变量，也是容易命名冲突的，在编译好的目标文件中，这些要算做 “顶级符号”（top-level symbol）。</strong></p>
<h2 id="3-2-提供-“全能初始化方法”"><a href="#3-2-提供-“全能初始化方法”" class="headerlink" title="3.2 提供 “全能初始化方法”"></a>3.2 提供 “全能初始化方法”</h2><p><strong>1.“全能初始化方法”（designated initializer）：为对象提供必要信息以便其能完成工作的初始化方法。</strong></p>
<p><strong>2.每个子类的全能初始化方法都应该调用其超类的对应方法，并逐层向上。</strong></p>
<ul>
<li>在类中提供一个全能初始化方法，并于文档里指明。其他初始化方法均应调用此方法。</li>
<li>若全能初始化方法与超类不同，则需覆写超类中的对应方法。</li>
<li>如果超类的初始化方法不适用于子类，那么应该覆写这个超类方法，并在其中抛出异常。</li>
</ul>
<h2 id="3-3-实现-description-方法"><a href="#3-3-实现-description-方法" class="headerlink" title="3.3 实现 description 方法"></a>3.3 实现 description 方法</h2><p><strong>1.在调用NSLog(@”object = %@”,onbject); 其实是调用了对象的description 方法。</strong></p>
<p><strong>2.在我们自定义类中，这样子打印输出信息有可能是这种object =，这个我们需要重写description 方法，让它返回我们需要的一些信息。</strong></p>
<p><strong>3.description 定义在NSObject 协议里面，因为NSObject 不是唯一的 “根类”，用继承不能很好的让其他类有这个方法</strong></p>
<blockquote>
<p>例如：NSProxy 也是遵从了NSObject 协议的 “根类”。</p>
</blockquote>
<p><strong>4.debugDescription 方法是开发者在调试器中以控制台命令打印对象时才调用的，默认是直接调用description 方法。</strong></p>
<p><strong>5.小技巧：可以在description 中用NSDictionary 的description 方法来输出，就是将信息用字典的形式来展示，这样子更加直观，也更加容易扩展。</strong></p>
<h2 id="3-4-尽量使用不可变对象"><a href="#3-4-尽量使用不可变对象" class="headerlink" title="3.4 尽量使用不可变对象"></a>3.4 尽量使用不可变对象</h2><p><strong>1.设计类的时候，用属性来封装数据，在用属性的时候，可将其声明为 “只读” ，避免外部不必要的修改</strong></p>
<blockquote>
<p>PS：如果把可变对象放到collection 之后又修改其内容，很容易会破坏set 的内部数据结构，使其失去固有的语义。</p>
</blockquote>
<p><strong>2.尽量把对外公布出来的属性设为只读，而且只在确有必要时才将属性对外公布。</strong></p>
<p><strong>3.当我们想外部暴露只读属性、内部需要修改属性，这样子通常是在内部将readonly 属性重新声明为readwrite。但是如果该属性是nonatomic 的，这样子做可能会产生 “竞争条件”（rece condition）。在对象内部写入某属性时，对象外的观察者也许正在读取该属性。若想避免此问题，我们可以在必要时通过 “派发队列”（dispatch queue）等手段，将所有的数据存取操作都设为同步操作。</strong></p>
<p><strong>4.虽然属性对外设置成readonly 了，但是外部仍能通过 “键值编码”（Key-Value Coding，KVC）技术设置这些属性值。[object setValue:@”abc” forKey:@”name”] ，这样子可以修改name 这个属性，KVC 会在类中查找 “setName：” 方法来修改属性值。</strong></p>
<p><strong>5.还可以通过类型信息查询功能，查出属性所对应的实例变量在内存中的偏移量，从此来人为设置这个实例变量的值。</strong></p>
<p><strong>注意点总结：</strong></p>
<ul>
<li>尽量创建不可变的对象。</li>
<li>若某属性仅可于对象内部修改，则在 “class-continuation 分类” 中将其由readonly 属性扩展成readwrite 属性。</li>
<li>不要把可变的collection 作为属性公开，而应提供相关方法，以此修改对象中的可变collection。</li>
</ul>
<h2 id="3-5-使用清晰而协调的命名方式"><a href="#3-5-使用清晰而协调的命名方式" class="headerlink" title="3.5 使用清晰而协调的命名方式"></a>3.5 使用清晰而协调的命名方式</h2><h3 id="1、方法与变量命名"><a href="#1、方法与变量命名" class="headerlink" title="1、方法与变量命名"></a>1、方法与变量命名</h3><p><strong>方法和变量名使用 “驼峰式大小写命名法”：以小写字母开头，其后每个单词首字母大写。</strong></p>
<p><strong>1.方法名言简意赅，能准确表达方法功能，不易太长。</strong></p>
<p><strong>2. 如果方法的返回值是新创建的，那么方法名的首个词应该是返回值的类型</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- stringWithString</span><br><span class="line"></span><br><span class="line">- intValue</span><br></pre></td></tr></table></figure>
<p><strong>除非前面还有修饰语，例如localizedString。属性的存取方法不遵循这种命名方式。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- localizedStringWithFormat:</span><br><span class="line"></span><br><span class="line">- initWith</span><br></pre></td></tr></table></figure>
<p><strong>3. 不要使用str这种简称，应该使用string 这样的全称。</strong></p>
<p><strong>4. Boolean 属性应加is前缀。如果某方法返回非属性的Boolean 值，那么应该根据其功能，选用has 或is 当前缀。</strong></p>
<p><strong>5. 将get 这个前缀留给那些借由 ”输出参数“ 来保存返回值的方法，比如说，把返回值填充到 ”C语言式数组“ 里的那种方法就可以使用这个词做前缀。</strong></p>
<h3 id="2、类与协议的命名"><a href="#2、类与协议的命名" class="headerlink" title="2、类与协议的命名"></a>2、类与协议的命名</h3><p><strong>1. 类名也采用驼峰式命名法，不过其首字母需要大写，通常还会加三个以上前缀字母，避免命名空间冲突。</strong></p>
<p><strong>2. 命名应该协调一致，从其他框架继承子类，务必遵循其命名惯例。</strong></p>
<blockquote>
<p>UIView 子类末尾必须是View，委托协议末尾必须是Delegate。</p>
</blockquote>
<p><strong>3. 起名时应遵从标准的Objective-C 命名规范，这样子创建出来的接口更容易为开发者所理解。</strong></p>
<h2 id="3-6-为私有方法名加前缀"><a href="#3-6-为私有方法名加前缀" class="headerlink" title="3.6 为私有方法名加前缀"></a>3.6 为私有方法名加前缀</h2><p><strong>1. 给私有方法的名称加上前缀，这样可以很容易地将其同公共方法区分开。</strong></p>
<blockquote>
<p>一种方案是加前缀 p_</p>
</blockquote>
<p><strong>2. 不要单用一个下划线做私有方法的前缀，因为这种做法是预留给苹果公司用的。</strong></p>
<h3 id="3-7-理解Objective-C-错误模型"><a href="#3-7-理解Objective-C-错误模型" class="headerlink" title="3.7 理解Objective-C 错误模型"></a>3.7 理解Objective-C 错误模型</h3><p><strong>1. ARC 默认不是 “异常安全的”，如果抛出异常，那么应在作用域末尾释放的对象现在却不会自动释放了。</strong></p>
<blockquote>
<p>想要生成 “异常安全的” 代码，可以设置编译器的标志来实现 “-fobjc-arc-exceptions”。但是这样没有异常的情况也会执行这些代码。</p>
</blockquote>
<p><strong>2. 平常很难写出在抛出异常时不会导致内存泄漏的代码，Objective-C 语言现在采用的办法是：只在极其罕见的情况下抛出异常，抛出异常应用程序直接退出，不考虑修复问题，不用再写复杂的 “异常安全” 代码。</strong></p>
<p><strong>3. 只有发生了可使整个应用程序崩溃的严重错误时，才应使用异常。</strong></p>
<p><strong>4. 在 “不那么严重的错误”，令方法返回nil/0，或者是使用NSError，表明其中有错误发生。</strong></p>
<blockquote>
<p>创建对象时，可用 返回nil/0/-1</p>
</blockquote>
<blockquote>
<p>方法逻辑错误或者需要详细错误信息时，考虑 NSError</p>
</blockquote>
<p><strong>5. NSError 可以经由此对象，把导致错误的原因回报给调用者。</strong></p>
<p><strong>NSError 可封装3条信息：</strong></p>
<ul>
<li>Error domain （错误范围，其类型为字符串）</li>
<li>Error code （错误码，其类型为整数）</li>
<li>User info （用户信息，其类型为字典）</li>
</ul>
<p><strong>1）通过委托协议（delegate）来传递NSError</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void) connection:(NSURLConnection *)connection didFailWithError:(NSError *)error;</span><br></pre></td></tr></table></figure>
<p><strong>2）经由方法的 “输出参数” 返回给调用者</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 方法定义</span><br><span class="line">// 返回 BOOL，容易判断（不需要查询 error 参数）。</span><br><span class="line">// NSError ** 为指向指针（NSError *）的指针</span><br><span class="line">- (BOOL) doSomething:(NSError **)error &#123;</span><br><span class="line">  if(/*there was an error*/)&#123;</span><br><span class="line">   // error 参数不是nil,不然解引用异常</span><br><span class="line">   if(error)&#123;</span><br><span class="line">         // *error 解引用，即NSError *指针指向新对象。</span><br><span class="line">         *error = [NSError errorWithDomain:domain</span><br><span class="line">                                      code:code</span><br><span class="line">                                  userInfo:userInfo];</span><br><span class="line">           return NO;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">      return YES;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 用法</span><br><span class="line">NSError *error = nil; // 如果想获取 eroor 详情，不能为 nil</span><br><span class="line">BOOL ret = [objecr doSomething:&amp;error]</span><br><span class="line">if(ret)&#123;</span><br><span class="line">    //to do</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-9-理解NSCopying-协议"><a href="#3-9-理解NSCopying-协议" class="headerlink" title="3.9 理解NSCopying 协议"></a>3.9 理解NSCopying 协议</h2><p><strong>1. 使用对象经常需要拷贝它，此操作通过copy 方法完成。如果想令自己的类支持拷贝操作，那就实现NSCopying 协议，该协议只有一个方法：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (id)copyWithZone:(NSZone *)zone</span><br></pre></td></tr></table></figure>
<p>不必担心zone参数</p>
<blockquote>
<p>以前开发程序，会把内存分成不同的 “区”（zone），而对象会创建在不同区里面，现在不用了，每个程序只有一个区：“默认区”（default zone）。因此不必担心 zone 参数</p>
</blockquote>
<p><strong>2. NSMutableCopying 协议跟NSCopying 类似，也只有一个方法：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (id)mutableCopyWithZone:(NSZone *)zone</span><br></pre></td></tr></table></figure>
<p><strong>3. 如果你的类分可变版本与不可变版本，这两个协议你都应该实现。</strong></p>
<p><strong>4. 注意：在可变对象上调用copy 方法返回另外一个不可变类的实例。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- [NSMutablArray copy] =&gt; NSArray</span><br><span class="line">- [NSArray mutableCopy] =&gt; NSmutableArray</span><br></pre></td></tr></table></figure>
<p><strong>5. 在编写拷贝方法时，还要确定一个问题：应该执行 “深拷贝”（deep copy）还是 “浅拷贝”（shallow copy）。</strong></p>
<p><strong>6. 深拷贝是指在拷贝对象自身时，将其底层的数据也一并复制过去；浅拷贝只对拷贝对象的指针，并不会拷贝底层的数据。Foundation 框架中的所有collection 类默认都执行浅拷贝。</strong></p>
<p><strong>7. 没有专门定义深拷贝的协议，所以具体执行方式由每个类来确定。另外不要假设遵从了NSCopying 协议的对象都会执行深拷贝。绝大多数情况下，执行的都是浅拷贝。</strong></p>
<p><strong>8. 如果你所写的对象需要深拷贝，那么可以考虑新增一个专门执行深拷贝的方法。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (id)initWithSet:(NSArray *)array copyItems:(BOOL)copyItems</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/13/hackintosh-summary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yun's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/13/hackintosh-summary/" itemprop="url">
                  Hackintosh 黑苹果总结
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-09-13 18:22:42" itemprop="dateCreated datePublished" datetime="2018-09-13T18:22:42+08:00">2018-09-13</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2018-09-26 17:21:34" itemprop="dateModified" datetime="2018-09-26T17:21:34+08:00">2018-09-26</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Hackintosh/" itemprop="url" rel="index"><span itemprop="name">Hackintosh</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Hackintosh-黑苹果总结"><a href="#Hackintosh-黑苹果总结" class="headerlink" title="Hackintosh 黑苹果总结"></a>Hackintosh 黑苹果总结</h1><blockquote>
<p>个人用黑苹果开发iOS、java已经有2年多。之所以选择黑苹果，还是因为 Macbook 性能太弱，而且发热严重。2年之久，基本随着 Mac系统更新，也会更新系统（不然无法更新最新的Xcode，纯 java 开发倒是无所谓）。只有一次打开【文件保险箱】功能挂了（下面有说明，千万不要打开该选项），其他时候都没问题。分享其中的一些经验，给愿意尝试黑苹果的朋友。</p>
</blockquote>
<ul>
<li><p>个人黑苹果电脑的配置：</p>
<p>  电脑一：台式机（i7-87000k 华擎 Z370M-ITX 16G GT750ti）</p>
<p>  电脑二：台式机（i5-4590 华硕 b85m 8G）</p>
<p>  电脑三：联想 Y700笔记本（i5-6300 8G GT960M）</p>
</li>
<li><p>帮人配的电脑：</p>
<p>  电脑一：台式机（i7-77000 华擎 deskmini 16G）</p>
<p>  电脑二：台式机（i5-7500 华硕 B150 8G）</p>
<p>  <a href="https://github.com/yunWJR/Hackintosh_List" target="_blank" rel="noopener">EIF 分享-包括以上提到的几种配置机型</a></p>
</li>
</ul>
<h2 id="一、哪些电脑可以安装黑苹果"><a href="#一、哪些电脑可以安装黑苹果" class="headerlink" title="一、哪些电脑可以安装黑苹果"></a>一、哪些电脑可以安装黑苹果</h2><h3 id="1、笔记本"><a href="#1、笔记本" class="headerlink" title="1、笔记本"></a>1、笔记本</h3><p>如何确定笔记本可以安装：</p>
<p>1）搜索笔记本型号，看有安装成功的案例没。</p>
<p>2）看CPU，如果 CPU 的型号与苹果已经发布的笔记本相同或类似（类似定义为同代 CPU），那么 CPU 应该没问题。</p>
<p>3）看显卡：如果笔记本有独显，那么独显基本是不能使用的，只能使用集显。偶尔少数笔记本有独显，主板不能屏蔽独显，导致无法安装。</p>
<p>4）以上满足的话，可以尝试安装。</p>
<h3 id="2、台式机"><a href="#2、台式机" class="headerlink" title="2、台式机"></a>2、台式机</h3><p>如何确定台式机可以安装：</p>
<p>1）搜索台式机配置，看有安装成功的案例没。</p>
<p>2）看CPU，如果CPU的型号与苹果已经发布的笔记本相同或类似（类似定义为同代 CPU），那么 CPU 应该没问题，基本都常见的 intel 台式机 CPU 都可以安装。最新的 AMD 都 CPU 也有大神放出内核，可以安装。</p>
<p>3）看显卡：如果有独显，比较新的 AMD 显卡都可以支持，N 卡一般也支持，有 WebDriver。</p>
<p>4）主板：一般都支持，技嘉的一般支持原生电源管理，比较好。华擎的支持比较到位，曾经几块主板专门出过安装黑苹果的 BIOS，良心。</p>
<p>5）网卡：一般 intel 的有线网卡都支持，无线的话，选择 苹果采用的型号，容易驱动。</p>
<h3 id="3、建议"><a href="#3、建议" class="headerlink" title="3、建议"></a>3、建议</h3><p>1）如果买新电脑</p>
<p>笔记本可以买没有独显的，因为有也一版用不上。先查下哪些比较好安装的机型，照着买就行。</p>
<p>台式机可以参考 <a href="https://www.tonymacx86.com/buyersguide/building-a-customac-hackintosh-the-ultimate-buyers-guide/" target="_blank" rel="noopener">tonymacx86</a>上的配置，都很容易安装。</p>
<p>2）最好配2块以上硬盘。</p>
<p>一块安装 Mac。另外一块安装 Windows，或者作为备份盘（TimeMachine）。如果作为生成环境使用，建议单独配置一块硬盘作为 TimeMachine 的备份盘。</p>
<p>3）如果要独显，最好选 AMD 的卡，可以很好的原生驱动。</p>
<p>4）如果配无线，最好选 Mac 电脑上用过的型号，容易驱动。</p>
<h2 id="二、安装流程"><a href="#二、安装流程" class="headerlink" title="二、安装流程"></a>二、安装流程</h2><h3 id="最简方式："><a href="#最简方式：" class="headerlink" title="最简方式："></a>最简方式：</h3><p>1、Mac 上 AppStore 中下载 Mac 系统</p>
<p>2、制作安装镜像到 U 盘，可以借助工具 <a href="http://diskmakerx.com/" target="_blank" rel="noopener">DiskMaker</a></p>
<p>3、制作 EFI 启动分区，可以制作在 U 盘上，也可以制作在硬盘上。</p>
<p>4、放入 EFI 分区启动文件（kext 和 config 配置文件等）</p>
<p>5、设置好 BIOS 选项</p>
<p>6、从 EFI 启动安装</p>
<p>7、完善安装（各硬件驱动）</p>
<p>8、完善 EFI，可将稳定的 EIF 文件，放入 Mac 分区的 EFI 分区。从 Mac 分区启动。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>1、不要随意升级 Mac 新版本，可能造成 kext 不兼容。</p>
<p>2、最好配一块备份盘，用 TimeMachine 备份。TimeMachine 确实好用。</p>
<p>3、一般不要去动 SLE 下的系统kext，也尽量不要把 kext 放入 SLE 下面，补丁 kext 都可以放在 EFI 下的 kext 中调试。</p>
<p>4、千万不要打开『安全与隐私』中的 【<strong>文件保险箱</strong>】功能，该功能与硬件相关，打开后，黑苹果就GG。</p>
<p>5、config 中的硬件 ID 尽量用同一个（同一台机子），新机子第一次安装时，随机生成一个。频繁更改 ID，会让你重新登录 AppleId。</p>
<h3 id="可以参考的网站"><a href="#可以参考的网站" class="headerlink" title="可以参考的网站"></a>可以参考的网站</h3><p><a href="https://www.tonymacx86.com/" target="_blank" rel="noopener">tonymacx86 - 国外很活跃度黑苹果网站，还有配置推荐</a></p>
<p><a href="http://bbs.pcbeta.com/forum.php?mod=forumdisplay&amp;fid=558&amp;filter=author&amp;orderby=dateline" target="_blank" rel="noopener">pcbeta - 国内活跃度黑苹果网站</a></p>
<p><a href="https://sourceforge.net/projects/cloverefiboot/" target="_blank" rel="noopener">cloverefiboot - clover项目现在地址</a></p>
<p><a href="https://bitbucket.org/RehabMan/" target="_blank" rel="noopener">RehabMan bitbucket -  RehabMan的 kext下载</a></p>
<p><a href="https://github.com/RehabMan" target="_blank" rel="noopener">RehabMan git - RehabMan的 kext下载和一些配置信息</a></p>
<p><a href="https://github.com/acidanthera" target="_blank" rel="noopener">acidanthera git - 作者写了很多有用的 kext</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/11/springcloud-summary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yun's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/11/springcloud-summary/" itemprop="url">
                  SpringCloud 概述
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-08-11 20:41:32" itemprop="dateCreated datePublished" datetime="2018-08-11T20:41:32+08:00">2018-08-11</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-01-08 08:20:08" itemprop="dateModified" datetime="2019-01-08T08:20:08+08:00">2019-01-08</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/SpringCloud/" itemprop="url" rel="index"><span itemprop="name">SpringCloud</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="SpringCloud-概述"><a href="#SpringCloud-概述" class="headerlink" title="SpringCloud 概述"></a>SpringCloud 概述</h1><h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><p>微服务是一个小的、松耦合的分布式服务。</p>
<h3 id="1、微服务的基础问题"><a href="#1、微服务的基础问题" class="headerlink" title="1、微服务的基础问题"></a>1、微服务的基础问题</h3><blockquote>
<p>服务粒度</p>
</blockquote>
<ul>
<li>服务职责单一</li>
<li>服务无状态话</li>
<li>操作表不能太多（3-5个）</li>
<li>避免简单的 CRUD服务</li>
</ul>
<blockquote>
<p>通信协议</p>
</blockquote>
<blockquote>
<p>接口设计</p>
</blockquote>
<ul>
<li>RESTful 风格接口</li>
<li>内容使用 JSON</li>
<li>HTTP 状态码表示结果</li>
</ul>
<blockquote>
<p>服务的配置管理 – Config</p>
</blockquote>
<pre><code>统一配置服务器，避免配置与服务硬绑定。
</code></pre><blockquote>
<p>服务之间的事件处理 – Stream</p>
</blockquote>
<pre><code>使用事件解耦微服务，最小化服务之间的硬编码依赖。
</code></pre><h3 id="2、微服务路由模式"><a href="#2、微服务路由模式" class="headerlink" title="2、微服务路由模式"></a>2、微服务路由模式</h3><p>负责处理客服端的服务请求，使其到达特定实例。</p>
<blockquote>
<p>服务路由（网关） – Netflix Zuul</p>
</blockquote>
<pre><code>为所有服务提供单个入口点，可整合安全策略、路由规则等。
</code></pre><blockquote>
<p>服务发现 – Netflix Eureka</p>
</blockquote>
<pre><code>微服务注册中心、管理服务。
</code></pre><h3 id="3、客服端弹性模式"><a href="#3、客服端弹性模式" class="headerlink" title="3、客服端弹性模式"></a>3、客服端弹性模式</h3><p>避免单个服务影响整个系统，提高服务稳定性。</p>
<blockquote>
<p>客服端负载均衡 – Neflix Ribbon</p>
</blockquote>
<pre><code>负载均衡，避免单个服务过载
</code></pre><blockquote>
<p>断路器模式 – Netflix Hystrix</p>
</blockquote>
<pre><code>阻止客户继续调用出故障/有性能问题的服务
</code></pre><blockquote>
<p>后备模式 – Netflix Hystrix</p>
</blockquote>
<pre><code>服务调用失败后，提供后备方案
</code></pre><blockquote>
<p>舱壁模式 – Netflix Hystrix</p>
</blockquote>
<pre><code>避免个别微服务故障影响整个服务。
</code></pre><h3 id="4、微服务安全"><a href="#4、微服务安全" class="headerlink" title="4、微服务安全"></a>4、微服务安全</h3><blockquote>
<p>验证 – Security/OAuth2</p>
</blockquote>
<pre><code>身份验证
</code></pre><blockquote>
<p>授权 – Security/OAuth2</p>
</blockquote>
<pre><code>权限验证
</code></pre><blockquote>
<p>凭据管理和传播  – Security/OAuth2 JWT</p>
</blockquote>
<pre><code>验证的模式 -JWT
</code></pre><h3 id="5、微服务日志记录与跟踪模式"><a href="#5、微服务日志记录与跟踪模式" class="headerlink" title="5、微服务日志记录与跟踪模式"></a>5、微服务日志记录与跟踪模式</h3><blockquote>
<p>日志关联 – Sleuth</p>
</blockquote>
<pre><code>关联请求在所有微服务中的调用链。
</code></pre><blockquote>
<p>日志聚合 – Sleuth、Papertrail</p>
</blockquote>
<pre><code>将所有微服务的日志聚合到一起
</code></pre><blockquote>
<p>微服务跟踪 – Sleuth/Zipkin</p>
</blockquote>
<pre><code>跟踪微服务的事物流程，以及其性能。
</code></pre><h3 id="6、微服务构建和部署"><a href="#6、微服务构建和部署" class="headerlink" title="6、微服务构建和部署"></a>6、微服务构建和部署</h3><blockquote>
<p>构建和部署管道</p>
</blockquote>
<pre><code>可重复的构建和部署过程。
</code></pre><blockquote>
<p>基础设施即代码</p>
</blockquote>
<blockquote>
<p>不可变服务器</p>
</blockquote>
<pre><code>部署之后永远不会改变
</code></pre><blockquote>
<p>凤凰服务器（Phoenix server）</p>
</blockquote>
<pre><code>服务长期一致性。
</code></pre><p><img src="http://qnyunyun.yunsoho.cn/20180626135647743.jpeg?imageMogr2/thumbnail/!100p" alt=""></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Yun</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">20</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">5</span>
                    <span class="site-state-item-name">categories</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">15</span>
                    <span class="site-state-item-name">tags</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yun</span>

  

  
</div>




  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Gemini</a> v6.4.1</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.4.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.4.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.4.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.4.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.4.1"></script>



  



  










  





  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
